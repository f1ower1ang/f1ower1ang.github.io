<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"f1ower1ang.top","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="随着应用越来越大，我们需要更加专注于状态的构建以及组件中的数据流转，繁杂的状态管理通常会引起一些bug。因此，本篇主要学习如何更好的构建状态，使得状态更新逻辑更具有维护性，以及如何在组件间共享状态。"><meta property="og:type" content="article"><meta property="og:title" content="跟着React官网学习3--状态管理"><meta property="og:url" content="https://f1ower1ang.top/26280791/index.html"><meta property="og:site_name" content="f1ower1ang&#39;s blog"><meta property="og:description" content="随着应用越来越大，我们需要更加专注于状态的构建以及组件中的数据流转，繁杂的状态管理通常会引起一些bug。因此，本篇主要学习如何更好的构建状态，使得状态更新逻辑更具有维护性，以及如何在组件间共享状态。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305061700921.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305061709885.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305061809416.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305061814890.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305071311213.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305071323667.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305071327209.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305071336588.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305071343793.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305071343274.png"><meta property="og:image" content="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt1.png&w=828&q=75"><meta property="og:image" content="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt2.png&w=828&q=75"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305071402950.png"><meta property="article:published_time" content="2023-05-06T06:53:51.000Z"><meta property="article:modified_time" content="2023-05-07T08:43:03.272Z"><meta property="article:author" content="f1ower1ang"><meta property="article:tag" content="前端"><meta property="article:tag" content="React"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305061700921.png"><link rel="canonical" href="https://f1ower1ang.top/26280791/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://f1ower1ang.top/26280791/","path":"26280791/","title":"跟着React官网学习3--状态管理"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>跟着React官网学习3--状态管理 | f1ower1ang's blog</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">f1ower1ang's blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">花语的学习记录</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-text">状态结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E7%9B%B8%E5%85%B3%E8%BF%9E%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-text">组合相关连的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0%E7%9F%9B%E7%9B%BE"><span class="nav-text">避免出现矛盾</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%86%97%E4%BD%99%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-text">避免冗余的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E7%8A%B6%E6%80%81%E9%87%8D%E5%A4%8D"><span class="nav-text">避免状态重复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E7%8A%B6%E6%80%81%E5%B5%8C%E5%A5%97%E5%B1%82%E7%BA%A7%E8%BF%87%E6%B7%B1"><span class="nav-text">避免状态嵌套层级过深</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E7%8A%B6%E6%80%81%E5%85%B1%E4%BA%AB"><span class="nav-text">组件间状态共享</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E6%83%85%E5%86%B5%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87"><span class="nav-text">视情况状态提升</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Context%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-text">使用Context共享数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAContext"><span class="nav-text">创建Context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Context"><span class="nav-text">使用Context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BE%9BContext"><span class="nav-text">提供Context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Context%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">Context使用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%9A%84%E4%BF%9D%E5%AD%98%E4%B8%8E%E9%87%8D%E7%BD%AE"><span class="nav-text">状态的保存与重置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E4%B8%8E%E5%85%B6%E5%9C%A8%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%85%B3%E8%81%94"><span class="nav-text">状态与其在树中的位置关联</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E7%9B%B8%E5%90%8C%E4%B8%94%E7%BB%84%E4%BB%B6%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%85%B6%E7%8A%B6%E6%80%81%E4%BC%9A%E8%A2%AB%E4%BF%9D%E5%AD%98"><span class="nav-text">位置相同且组件相同，其状态会被保存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%8D%E5%90%8C%E4%BD%86%E4%BD%8D%E7%BD%AE%E7%9B%B8%E5%90%8C%E4%BC%9A%E9%87%8D%E7%BD%AE%E7%8A%B6%E6%80%81"><span class="nav-text">组件不同但位置相同会重置状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%B5%8C%E5%A5%97%E5%A3%B0%E6%98%8E%E7%BB%84%E4%BB%B6"><span class="nav-text">不能在组件中嵌套声明组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E7%BD%AE%E5%9C%A8%E5%90%8C%E4%B8%80%E4%BD%8D%E7%BD%AE%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-text">重置在同一位置组件的状态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%86%E7%8A%B6%E6%80%81%E9%80%BB%E8%BE%91%E6%8A%BD%E7%A6%BB%E5%88%B0Reducer%E4%B8%AD"><span class="nav-text">将状态逻辑抽离到Reducer中</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#useState-vs-useReducer"><span class="nav-text">useState vs useReducer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Immer%E6%9D%A5%E7%AE%80%E5%8C%96reducers%E7%9A%84%E5%86%99%E6%B3%95"><span class="nav-text">使用Immer来简化reducers的写法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%94%BE%E5%A4%A7Reducer%E5%92%8CContext%E7%9A%84%E6%95%88%E6%9E%9C"><span class="nav-text">放大Reducer和Context的效果</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8AReducer%E5%92%8CContext%E7%BB%93%E5%90%88%E8%B5%B7%E6%9D%A5"><span class="nav-text">把Reducer和Context结合起来</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAContext-1"><span class="nav-text">创建Context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8A%E7%8A%B6%E6%80%81%E5%92%8CContext%E5%B5%8C%E5%85%A5Context"><span class="nav-text">把状态和Context嵌入Context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E9%9C%80%E5%9C%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8Context"><span class="nav-text">按需在子组件中使用Context</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%90%E5%8F%96%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="nav-text">提取到一个文件中</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="f1ower1ang" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">f1ower1ang</p><div class="site-description" itemprop="description">“静坐常思己过，闲聊莫论人非”</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://f1ower1ang.top/26280791/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="f1ower1ang"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="f1ower1ang's blog"><meta itemprop="description" content="“静坐常思己过，闲聊莫论人非”"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="跟着React官网学习3--状态管理 | f1ower1ang's blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">跟着React官网学习3--状态管理</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-05-06 14:53:51" itemprop="dateCreated datePublished" datetime="2023-05-06T14:53:51+08:00">2023-05-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-05-07 16:43:03" itemprop="dateModified" datetime="2023-05-07T16:43:03+08:00">2023-05-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%B7%9F%E7%9D%80%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0React/" itemprop="url" rel="index"><span itemprop="name">跟着官网学习React</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>4.6k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>17 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>随着应用越来越大，我们需要更加专注于状态的构建以及组件中的数据流转，繁杂的状态管理通常会引起一些bug。因此，本篇主要学习如何更好的构建状态，使得状态更新逻辑更具有维护性，以及如何在组件间共享状态。</p></blockquote><span id="more"></span><h1 id="状态结构设计"><a href="#状态结构设计" class="headerlink" title="状态结构设计"></a>状态结构设计</h1><p>良好的状态结构有利于组件重构和调试，还能减少一些隐秘的bug。可以参考以下规则来构建状态：</p><h2 id="组合相关连的状态"><a href="#组合相关连的状态" class="headerlink" title="组合相关连的状态"></a>组合相关连的状态</h2><p>如果经常同时更新两个以上状态值，可以考虑将他们合并为一个状态。</p><p>例如记录某元素的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const [x, setX] = useState(0)</span><br><span class="line">const [y, setY] = useState(0)</span><br></pre></td></tr></table></figure><p>可以把它改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [position, setPosition] = useState(&#123; x: 0, y: 0 &#125;);</span><br></pre></td></tr></table></figure><h2 id="避免出现矛盾"><a href="#避免出现矛盾" class="headerlink" title="避免出现矛盾"></a>避免出现矛盾</h2><p>如果一个状态由其他多个状态计算而来，应考虑这样的设计存在矛盾。</p><p>例如记录酒店某间房间是否出售，通过两个状态<code>isSending</code>和<code>isSent</code>来分别记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const [isSending, setIsSending] = useState(false);</span><br><span class="line">const [isSent, setIsSent] = useState(false);</span><br></pre></td></tr></table></figure><p>虽然这样设计能够让程序正常运行，但它们之间存在矛盾，因为房间售卖的状态只有一种，只需要设置一个状态来记录即可，因此把这两个状态稍微修改一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const [status, setStatus] = useState(&#x27;typing&#x27;)</span><br><span class="line">const isSending = status === &#x27;sending&#x27;</span><br><span class="line">const isSent = status === &#x27;sent&#x27;</span><br></pre></td></tr></table></figure><h2 id="避免冗余的状态"><a href="#避免冗余的状态" class="headerlink" title="避免冗余的状态"></a>避免冗余的状态</h2><p>如果能从组件的props或者当前的状态中计算出一些信息，没必要将该信息保存为一个状态。</p><p>例如从用户输入的姓和名获取完整的名字信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const [firstName, setFirstName] = useState(&#x27;&#x27;);</span><br><span class="line">const [lastName, setLastName] = useState(&#x27;&#x27;);</span><br><span class="line">const [fullName, setFullName] = useState(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">function handleFirstNameChange(e) &#123;</span><br><span class="line">  setFirstName(e.target.value);</span><br><span class="line">  setFullName(e.target.value + &#x27; &#x27; + lastName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleLastNameChange(e) &#123;</span><br><span class="line">  setLastName(e.target.value);</span><br><span class="line">  setFullName(firstName + &#x27; &#x27; + e.target.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里设置的<code>fullName</code>就是一个冗余状态，完全可以由前两个状态计算得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const [firstName, setFirstName] = useState(&#x27;&#x27;);</span><br><span class="line">const [lastName, setLastName] = useState(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">const fullName = firstName + &#x27; &#x27; + lastName;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：不要为props创建新的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Message(&#123; messageColor &#125;) &#123;</span><br><span class="line">  const [color, setColor] = useState(messageColor);</span><br></pre></td></tr></table></figure><p>应写成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Message(&#123; messageColor &#125;) &#123;</span><br><span class="line">  const color = messageColor;</span><br></pre></td></tr></table></figure><h2 id="避免状态重复"><a href="#避免状态重复" class="headerlink" title="避免状态重复"></a>避免状态重复</h2><p>例如我们要从一个列表中显示当前选中的元素，直觉上会直接把选中的元素设置为另一个状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const initialItems = [</span><br><span class="line">  &#123; title: &#x27;pretzels&#x27;, id: 0 &#125;,</span><br><span class="line">  &#123; title: &#x27;crispy seaweed&#x27;, id: 1 &#125;,</span><br><span class="line">  &#123; title: &#x27;granola bar&#x27;, id: 2 &#125;,</span><br><span class="line">];</span><br><span class="line">const [items, setItems] = useState(initialItems);</span><br><span class="line">const [selectedItem, setSelectedItem] = useState(items[0]);</span><br><span class="line"></span><br><span class="line">function handleSelect(item) &#123;</span><br><span class="line">  setSelectedItem(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleItemChange(id, e) &#123;</span><br><span class="line">  setItems(items.map(item =&gt; &#123;</span><br><span class="line">    if (item.id === id) &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        title: e.target.value,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样有一个问题是，如果已选中的元素发生变化，并不会触发<code>selectedItem</code>的更新，因为每次更新状态数组对象，都会生成新的对象，对应的<code>selectedItem</code>中对象的引用关系发生了变化。</p><p>这种情况下，我们只需将选中元素的关键信息(<code>id</code>)用状态保存即可，其他信息可以从数组状态中计算而来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const [selectedId, setSelectedId] = useState(0);</span><br><span class="line"></span><br><span class="line">const selectedItem = items.find(item =&gt;</span><br><span class="line">  item.id === selectedId</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">function handleSelect(id) &#123;</span><br><span class="line">  setSelectedId(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免状态嵌套层级过深"><a href="#避免状态嵌套层级过深" class="headerlink" title="避免状态嵌套层级过深"></a>避免状态嵌套层级过深</h2><p>例如有一个类似于多叉树的数据结构。正常我们会用数组描述其子元素，然后子元素又有它的子元素，当层级过深使得数据难以处理，比较好的办法是将这类数据铺平，以<code>id</code>为索引，来值为元素信息，其中子元素是记录其<code>id</code>。</p><h1 id="组件间状态共享"><a href="#组件间状态共享" class="headerlink" title="组件间状态共享"></a>组件间状态共享</h1><h2 id="视情况状态提升"><a href="#视情况状态提升" class="headerlink" title="视情况状态提升"></a>视情况状态提升</h2><p>有时候我们想同步更新多个组件的状态，例如控制多个子组件的展示状态，即一段时间内只允许一个组件显示，其他隐藏。这种情况下，我们需要将控制子组件显示的状态进行提升，由父组件来控制。因此这里有三个步骤：移除子组件的相关状态、将该状态提升至最近的公共父组件、通过props将状态传递给子组件。</p><p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305061700921.png" alt="The same diagram as the previous, with the isActive of the first child Panel component highlighted indicating a click with the isActive value set to true. The second Panel component still contains value false."></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function Accordion() &#123;</span><br><span class="line">  const [activeIndex, setActiveIndex] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h2&gt;Almaty, Kazakhstan&lt;/h2&gt;</span><br><span class="line">      &lt;Panel</span><br><span class="line">        title=&quot;About&quot;</span><br><span class="line">        isActive=&#123;activeIndex === 0&#125;</span><br><span class="line">        onShow=&#123;() =&gt; setActiveIndex(0)&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        With a population of about 2 million, Almaty is Kazakhstan&#x27;s largest city. From 1929 to 1997, it was its capital city.</span><br><span class="line">      &lt;/Panel&gt;</span><br><span class="line">      &lt;Panel</span><br><span class="line">        title=&quot;Etymology&quot;</span><br><span class="line">        isActive=&#123;activeIndex === 1&#125;</span><br><span class="line">        onShow=&#123;() =&gt; setActiveIndex(1)&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        The name comes from &lt;span lang=&quot;kk-KZ&quot;&gt;алма&lt;/span&gt;, the Kazakh word for &quot;apple&quot; and is often translated as &quot;full of apples&quot;. In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild &lt;i lang=&quot;la&quot;&gt;Malus sieversii&lt;/i&gt; is considered a likely candidate for the ancestor of the modern domestic apple.</span><br><span class="line">      &lt;/Panel&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Panel(&#123;</span><br><span class="line">  title,</span><br><span class="line">  children,</span><br><span class="line">  isActive,</span><br><span class="line">  onShow</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;section className=&quot;panel&quot;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;title&#125;&lt;/h3&gt;</span><br><span class="line">      &#123;isActive ? (</span><br><span class="line">        &lt;p&gt;&#123;children&#125;&lt;/p&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;button onClick=&#123;onShow&#125;&gt;</span><br><span class="line">          Show</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用Context共享数据"><a href="#使用Context共享数据" class="headerlink" title="使用Context共享数据"></a>使用Context共享数据</h2><p>通常从父组件向子组件传递数据会使用props，这种方式比较直观。但随着组件嵌套层级过深，会变得不方便，这时候我们可以使用Context完成这种深层级的组件通信。其实组件间状态共享也是一种父子组件通信的一种，只不过这时的父组件是根组件。</p><p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305061709885.png" alt="image-20230506170929836"></p><p>以上是通过props给子组件传递数据，可以看出当嵌套层级过深时，会出现<code>prop drilling</code>。</p><p>例如，控制标题大小的显示</p><p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305061809416.png" alt="image-20230506180905338"></p><p>需要手动给每个标题组件传入层级<code>level</code>，以控制字体大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">export default function Page() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Section&gt;</span><br><span class="line">      &lt;Heading level=&#123;1&#125;&gt;Title&lt;/Heading&gt;</span><br><span class="line">      &lt;Section&gt;</span><br><span class="line">        &lt;Heading level=&#123;2&#125;&gt;Heading&lt;/Heading&gt;</span><br><span class="line">        &lt;Heading level=&#123;2&#125;&gt;Heading&lt;/Heading&gt;</span><br><span class="line">        &lt;Heading level=&#123;2&#125;&gt;Heading&lt;/Heading&gt;</span><br><span class="line">        &lt;Section&gt;</span><br><span class="line">          &lt;Heading level=&#123;3&#125;&gt;Sub-heading&lt;/Heading&gt;</span><br><span class="line">          &lt;Heading level=&#123;3&#125;&gt;Sub-heading&lt;/Heading&gt;</span><br><span class="line">          &lt;Heading level=&#123;3&#125;&gt;Sub-heading&lt;/Heading&gt;</span><br><span class="line">          &lt;Section&gt;</span><br><span class="line">            &lt;Heading level=&#123;4&#125;&gt;Sub-sub-heading&lt;/Heading&gt;</span><br><span class="line">            &lt;Heading level=&#123;4&#125;&gt;Sub-sub-heading&lt;/Heading&gt;</span><br><span class="line">            &lt;Heading level=&#123;4&#125;&gt;Sub-sub-heading&lt;/Heading&gt;</span><br><span class="line">          &lt;/Section&gt;</span><br><span class="line">        &lt;/Section&gt;</span><br><span class="line">      &lt;/Section&gt;</span><br><span class="line">    &lt;/Section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能通过设置<code>Section</code>就能控制<code>Heading</code>的样式，不论在代码美观度还是开发的便捷性上都有优势。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Section level=&#123;3&#125;&gt;</span><br><span class="line">  &lt;Heading&gt;About&lt;/Heading&gt;</span><br><span class="line">  &lt;Heading&gt;Photos&lt;/Heading&gt;</span><br><span class="line">  &lt;Heading&gt;Videos&lt;/Heading&gt;</span><br><span class="line">&lt;/Section&gt;</span><br></pre></td></tr></table></figure><p>这时候可以使用Context来完成组件通信。</p><p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305061814890.png" alt="image-20230506181440846"></p><p>分为三步：创建Context、使用Context、提供Context。</p><h3 id="创建Context"><a href="#创建Context" class="headerlink" title="创建Context"></a>创建Context</h3><p>Context单独声明在一个JS文件中，导出Context实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// LevelContext.js</span><br><span class="line">import &#123; createContext &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export const LevelContext = createContext(1);</span><br></pre></td></tr></table></figure><h3 id="使用Context"><a href="#使用Context" class="headerlink" title="使用Context"></a>使用Context</h3><p>哪个组件需要用到父组件传过来的数据，就在该组件下使用Context，这里是Heading组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useContext &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; LevelContext &#125; from &#x27;./LevelContext.js&#x27;;</span><br><span class="line"></span><br><span class="line">export default function Heading(&#123; children &#125;) &#123;</span><br><span class="line">  const level = useContext(LevelContext);</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提供Context"><a href="#提供Context" class="headerlink" title="提供Context"></a>提供Context</h3><p>即给Context注入要传递给子组件的数据，这里是<code>Section</code>组件从父组件接收level，然后将其通过Context提供给子组件使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; LevelContext &#125; from &#x27;./LevelContext.js&#x27;;</span><br><span class="line"></span><br><span class="line">export default function Section(&#123; level, children &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;section className=&quot;section&quot;&gt;</span><br><span class="line">      &lt;LevelContext.Provider value=&#123;level&#125;&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">      &lt;/LevelContext.Provider&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能做到只需给<code>Section</code>传递<code>level</code>，其子组件就能获取父组件提供的<code>Context</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import Heading from &#x27;./Heading.js&#x27;;</span><br><span class="line">import Section from &#x27;./Section.js&#x27;;</span><br><span class="line"></span><br><span class="line">export default function Page() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Section level=&#123;1&#125;&gt;</span><br><span class="line">      &lt;Heading&gt;Title&lt;/Heading&gt;</span><br><span class="line">      &lt;Section level=&#123;2&#125;&gt;</span><br><span class="line">        &lt;Heading&gt;Heading&lt;/Heading&gt;</span><br><span class="line">        &lt;Heading&gt;Heading&lt;/Heading&gt;</span><br><span class="line">        &lt;Heading&gt;Heading&lt;/Heading&gt;</span><br><span class="line">        &lt;Section level=&#123;3&#125;&gt;</span><br><span class="line">          &lt;Heading&gt;Sub-heading&lt;/Heading&gt;</span><br><span class="line">          &lt;Heading&gt;Sub-heading&lt;/Heading&gt;</span><br><span class="line">          &lt;Heading&gt;Sub-heading&lt;/Heading&gt;</span><br><span class="line">          &lt;Section level=&#123;4&#125;&gt;</span><br><span class="line">            &lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;</span><br><span class="line">            &lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;</span><br><span class="line">            &lt;Heading&gt;Sub-sub-heading&lt;/Heading&gt;</span><br><span class="line">          &lt;/Section&gt;</span><br><span class="line">        &lt;/Section&gt;</span><br><span class="line">      &lt;/Section&gt;</span><br><span class="line">    &lt;/Section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Context使用场景"><a href="#Context使用场景" class="headerlink" title="Context使用场景"></a>Context使用场景</h3><ul><li><strong>主题</strong>。如果应用需要实现皮肤切换，可以让根组件提供Context，其他子组件使用Context，并根据值来调整外观。</li><li><strong>用户信息</strong>。许多组件可能需要知道当前登录的用户信息，Context可以比较方便的获取相关数据。</li><li><strong>路由信息</strong>。大部分路由解决方案都采用Context来管理当前的路由信息。</li><li><strong>状态管理</strong>。当我们想在深层级的组件间共享状态时，使用Context可以解决因为组件嵌套层级过深，出现prop drilling的问题。</li></ul><h1 id="状态的保存与重置"><a href="#状态的保存与重置" class="headerlink" title="状态的保存与重置"></a>状态的保存与重置</h1><p>状态独立于组件之外，React会根据他们在UI树上的位置来记录状态和组件的对应关系，我们可以控制组件渲染时状态应该保存还是重置。</p><p>浏览器使用许多树结构来构建UI，如DOM树、CSSOM树等，在React中也使用树结构来管理和构建UI，它是根据JSX生成的。然后再将其渲染成DOM树。</p><p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305071311213.png" alt="Diagram with three sections arranged horizontally. In the first section, there are three rectangles stacked vertically, with labels &#39;Component A&#39;, &#39;Component B&#39;, and &#39;Component C&#39;. Transitioning to the next pane is an arrow with the React logo on top labeled &#39;React&#39;. The middle section contains a tree of components, with the root labeled &#39;A&#39; and two children labeled &#39;B&#39; and &#39;C&#39;. The next section is again transitioned using an arrow with the React logo on top labeled &#39;React&#39;. The third and final section is a wireframe of a browser, containing a tree of 8 nodes, which has only a subset highlighted (indicating the subtree from the middle section)."></p><h2 id="状态与其在树中的位置关联"><a href="#状态与其在树中的位置关联" class="headerlink" title="状态与其在树中的位置关联"></a>状态与其在树中的位置关联</h2><p>React根据组件在UI树上的位置来管理其中的状态。</p><p>例如有如下UI树，当其中一个卸载后重新挂载，该组件中的状态会重置，而不会影响另一个组件的状态，虽然它们来自于同一个组件。</p><p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305071323667.png" alt="Diagram of a tree of React components. The root node is labeled &#39;div&#39; and has two children. Each of the children are labeled &#39;Counter&#39; and both contain a state bubble labeled &#39;count&#39; with value 0."></p><p>修改第二个<code>Counter</code>组件中的<code>count</code>值为1。然后将其卸载后重新挂载，可以发现状态重置了。</p><p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305071327209.png" alt="Diagram of a tree of React components. The root node is labeled &#39;div&#39; and has two children. The left child is labeled &#39;Counter&#39; and contains a state bubble labeled &#39;count&#39; with value 0. The right child is labeled &#39;Counter&#39; and contains a state bubble labeled &#39;count&#39; with value 0. The entire right child node is highlighted in yellow, indicating that it was just added to the tree."></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export default function App() &#123;</span><br><span class="line">  const [showB, setShowB] = useState(true);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Counter /&gt;</span><br><span class="line">      &#123;showB &amp;&amp; &lt;Counter /&gt;&#125; </span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;checkbox&quot;</span><br><span class="line">          checked=&#123;showB&#125;</span><br><span class="line">          onChange=&#123;e =&gt; &#123;</span><br><span class="line">            setShowB(e.target.checked)</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        Render the second counter</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位置相同且组件相同，其状态会被保存"><a href="#位置相同且组件相同，其状态会被保存" class="headerlink" title="位置相同且组件相同，其状态会被保存"></a>位置相同且组件相同，其状态会被保存</h2><p>组件相同是指类型相同，即组件名和<code>key</code>值相同，位置相同是指其在UI树上的位置。</p><p>如下面代码所示，给<code>Counter</code>的<code>props</code>传入不同的值来控制其显示效果，但不会重置其中状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">export default function App() &#123;</span><br><span class="line">  const [isFancy, setIsFancy] = useState(false);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isFancy ? (</span><br><span class="line">        &lt;Counter isFancy=&#123;true&#125; /&gt; </span><br><span class="line">      ) : (</span><br><span class="line">        &lt;Counter isFancy=&#123;false&#125; /&gt; </span><br><span class="line">      )&#125;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;checkbox&quot;</span><br><span class="line">          checked=&#123;isFancy&#125;</span><br><span class="line">          onChange=&#123;e =&gt; &#123;</span><br><span class="line">            setIsFancy(e.target.checked)</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        Use fancy styling</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305071336588.png" alt="Diagram with two sections separated by an arrow transitioning between them. Each section contains a layout of components with a parent labeled &#39;App&#39; containing a state bubble labeled isFancy. This component has one child labeled &#39;div&#39;, which leads to a prop bubble containing isFancy (highlighted in purple) passed down to the only child. The last child is labeled &#39;Counter&#39; and contains a state bubble with label &#39;count&#39; and value 3 in both diagrams. In the left section of the diagram, nothing is highlighted and the isFancy parent state value is false. In the right section of the diagram, the isFancy parent state value has changed to true and it is highlighted in yellow, and so is the props bubble below, which has also changed its isFancy value to true."></p><p>在React看来，他们就是同一个组件，所以不会重置状态。</p><p><strong>注意</strong>：组件的位置是指在<strong>UI树中的位置</strong>，而不是JSX中的位置。</p><p>例如，将上述代码改写一下，效果还是不变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">export default function App() &#123;</span><br><span class="line">  const [isFancy, setIsFancy] = useState(false);</span><br><span class="line">  if (isFancy) &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Counter isFancy=&#123;true&#125; /&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          &lt;input</span><br><span class="line">            type=&quot;checkbox&quot;</span><br><span class="line">            checked=&#123;isFancy&#125;</span><br><span class="line">            onChange=&#123;e =&gt; &#123;</span><br><span class="line">              setIsFancy(e.target.checked)</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          Use fancy styling</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Counter isFancy=&#123;false&#125; /&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;checkbox&quot;</span><br><span class="line">          checked=&#123;isFancy&#125;</span><br><span class="line">          onChange=&#123;e =&gt; &#123;</span><br><span class="line">            setIsFancy(e.target.checked)</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        Use fancy styling</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件不同但位置相同会重置状态"><a href="#组件不同但位置相同会重置状态" class="headerlink" title="组件不同但位置相同会重置状态"></a>组件不同但位置相同会重置状态</h2><p>例如，根据<code>isPaused</code>来条件渲染<code>&lt;Counter&gt;</code>和<code>&lt;p&gt;</code>，由于这两个组件不同，因此会重置他们的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">export default function App() &#123;</span><br><span class="line">  const [isPaused, setIsPaused] = useState(false);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isPaused ? (</span><br><span class="line">        &lt;p&gt;See you later!&lt;/p&gt; </span><br><span class="line">      ) : (</span><br><span class="line">        &lt;Counter /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;checkbox&quot;</span><br><span class="line">          checked=&#123;isPaused&#125;</span><br><span class="line">          onChange=&#123;e =&gt; &#123;</span><br><span class="line">            setIsPaused(e.target.checked)</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        Take a break</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center class="half"><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305071343793.png"> <img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305071343274.png"></center><p>当React在同一个位置渲染不同的组件，它也会将该组件下的所有子树的状态重置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">export default function App() &#123;</span><br><span class="line">  const [isFancy, setIsFancy] = useState(false);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isFancy ? (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Counter isFancy=&#123;true&#125; /&gt; </span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;section&gt;</span><br><span class="line">          &lt;Counter isFancy=&#123;false&#125; /&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;checkbox&quot;</span><br><span class="line">          checked=&#123;isFancy&#125;</span><br><span class="line">          onChange=&#123;e =&gt; &#123;</span><br><span class="line">            setIsFancy(e.target.checked)</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        Use fancy styling</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center class="half"><img data-src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt1.png&w=828&q=75"> <img data-src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt2.png&w=828&q=75"></center><h3 id="不能在组件中嵌套声明组件"><a href="#不能在组件中嵌套声明组件" class="headerlink" title="不能在组件中嵌套声明组件"></a>不能在组件中嵌套声明组件</h3><p>例如我们在一个组件<code>MyComponent</code>中声明另一个组件<code>MyTextField</code>，并将其作为JSX标记渲染，每当组件中其他状态改变时，<code>MyTextField</code>会被重新声明，这时组件在同一个位置但类型不同，就会重置<code>MyTextField</code>中的状态，从而引起不必要的渲染和性能开销。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export default function MyComponent() &#123;</span><br><span class="line">  const [counter, setCounter] = useState(0);</span><br><span class="line"></span><br><span class="line">  function MyTextField() &#123;</span><br><span class="line">    const [text, setText] = useState(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;input</span><br><span class="line">        value=&#123;text&#125;</span><br><span class="line">        onChange=&#123;e =&gt; setText(e.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;MyTextField /&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setCounter(counter + 1)</span><br><span class="line">      &#125;&#125;&gt;Clicked &#123;counter&#125; times&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重置在同一位置组件的状态"><a href="#重置在同一位置组件的状态" class="headerlink" title="重置在同一位置组件的状态"></a>重置在同一位置组件的状态</h2><p>通常在同一个位置下的且组件名相同的组件，其状态默认不会被重置，有时这不是我们想要的。以下有两种方式可以重置状态：</p><ul><li>让组件渲染在不同的位置</li><li>给每个组件唯一的标识<code>key</code>。给组件的<code>key</code>属性传入一个唯一值，这个值只需在当前组件中是唯一的，不需在全局下唯一。</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202305071402950.png" alt="image-20230507140213875"></p><h1 id="将状态逻辑抽离到Reducer中"><a href="#将状态逻辑抽离到Reducer中" class="headerlink" title="将状态逻辑抽离到Reducer中"></a>将状态逻辑抽离到Reducer中</h1><p>组件内状态多，状态更新逻辑变得复杂且难以维护，这时我们可以将逻辑相同的部分抽离到单独的函数中，该函数称为<code>Reducer</code>。</p><p>例如我们需要对一个状态数组完成<code>增、删、改</code>操作，一般情况下会声明三个函数，并使用状态的<code>setter</code>来修改相关状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function handleAddTask(text) &#123;</span><br><span class="line">  setTasks([</span><br><span class="line">    ...tasks,</span><br><span class="line">    &#123;</span><br><span class="line">      id: nextId++,</span><br><span class="line">      text: text,</span><br><span class="line">      done: false,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleChangeTask(task) &#123;</span><br><span class="line">  setTasks(</span><br><span class="line">    tasks.map((t) =&gt; &#123;</span><br><span class="line">      if (t.id === task.id) &#123;</span><br><span class="line">        return task;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleDeleteTask(taskId) &#123;</span><br><span class="line">  setTasks(tasks.filter((t) =&gt; t.id !== taskId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然函数名的语义化能让我们看出相关操作，但其中的操作逻辑抽离成一个函数，通过传入不同的参数来表示不同的行为，如改为下面这种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function handleAddTask(text) &#123;</span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: &#x27;added&#x27;,</span><br><span class="line">    id: nextId++,</span><br><span class="line">    text: text,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleChangeTask(task) &#123;</span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: &#x27;changed&#x27;,</span><br><span class="line">    task: task,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleDeleteTask(taskId) &#123;</span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: &#x27;deleted&#x27;,</span><br><span class="line">    id: taskId,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是我们最终想要的效果，可以借助<code>Reducer</code>完成。通常分为三步：</p><ul><li>从调用状态的<code>setter</code>方法改为<code>dispatch</code>行为完成状态的修改。</li><li>声明一个<code>reducer</code>函数，用来处理不同行为。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param tasks: 状态</span><br><span class="line"> * @param action: dispatch方法传入的第一个参数</span><br><span class="line"> * @return 修改后的状态</span><br><span class="line"> */</span><br><span class="line">function tasksReducer(tasks, action) &#123;</span><br><span class="line">  if (action.type === &#x27;added&#x27;) &#123;</span><br><span class="line">    return [</span><br><span class="line">      ...tasks,</span><br><span class="line">      &#123;</span><br><span class="line">        id: action.id,</span><br><span class="line">        text: action.text,</span><br><span class="line">        done: false,</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">  &#125; else if (action.type === &#x27;changed&#x27;) &#123;</span><br><span class="line">    return tasks.map((t) =&gt; &#123;</span><br><span class="line">      if (t.id === action.task.id) &#123;</span><br><span class="line">        return action.task;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else if (action.type === &#x27;deleted&#x27;) &#123;</span><br><span class="line">    return tasks.filter((t) =&gt; t.id !== action.id);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw Error(&#x27;Unknown action: &#x27; + action.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在对应的组件中使用<code>reducer</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 引入包</span><br><span class="line">import &#123; useReducer &#125; from &#x27;react&#x27;;</span><br><span class="line">// 把 useState 替换为 useReducer</span><br><span class="line">const [ tasks, dispatch ] = useReducer(tasksReducer, initialTasks)</span><br></pre></td></tr></table></figure><p>需要<strong>注意</strong>的是：<code>reducer必须是纯函数</code>、<code>一个action只能描述一种用户交互行为，即使该行为会导致多个状态变化</code></p><h2 id="useState-vs-useReducer"><a href="#useState-vs-useReducer" class="headerlink" title="useState vs useReducer"></a><code>useState</code> vs <code>useReducer</code></h2><p>reducer并非没有缺点，以下是它们的对比：</p><ul><li><strong>代码大小</strong>：通常，使用<code>useState</code>，必须预先编写更少的代码。使用<code>useReducer</code>，必须同时reducer函数和dispatch行为。但是，如果许多事件处理程序有相似逻辑，则可以减少代码量。</li><li><strong>可读性</strong>：当状态更新逻辑简单时，<code>useState</code>非常容易阅读。当它们变得复杂时，会使得代码变得臃肿，这种情况下，<code>useReducer</code>可以简化更新操作。</li><li><strong>调试</strong>：当使用<code>useState</code>发生错误时，可能很难发现状态的设置错误。使用<code>useReducer</code>可以在reducer中打印日志信息，以查看每个状态的更新信息和相关逻辑。如果每个行为都是正确的，那么错误发生在reducer函数中。但是，代码量也相应增加。</li><li><strong>测试</strong>：reducer是一个不依赖于组件的<code>纯函数</code>，这意味着可以直接单独导出并测试。</li><li><strong>个人偏好</strong>：有些人喜欢reducer，其他人则不喜欢。这是一个偏爱问题，可以在他俩之间来回转换，它们是等效的。</li></ul><h2 id="使用Immer来简化reducers的写法"><a href="#使用Immer来简化reducers的写法" class="headerlink" title="使用Immer来简化reducers的写法"></a>使用<code>Immer</code>来简化<code>reducers</code>的写法</h2><p>通过<code>useImmerReducer</code>可以简化<code>reducer</code>中对状态修改的操作，写法和前文提过的类似。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useImmerReducer &#125; from &#x27;use-immer&#x27;;</span><br><span class="line"></span><br><span class="line">function tasksReducer(draft, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#x27;added&#x27;: &#123;</span><br><span class="line">      draft.push(&#123;</span><br><span class="line">        id: action.id,</span><br><span class="line">        text: action.text,</span><br><span class="line">        done: false,</span><br><span class="line">      &#125;);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    case &#x27;changed&#x27;: &#123;</span><br><span class="line">      const index = draft.findIndex((t) =&gt; t.id === action.task.id);</span><br><span class="line">      draft[index] = action.task;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    case &#x27;deleted&#x27;: &#123;</span><br><span class="line">      return draft.filter((t) =&gt; t.id !== action.id);</span><br><span class="line">    &#125;</span><br><span class="line">    default: &#123;</span><br><span class="line">      throw Error(&#x27;Unknown action: &#x27; + action.type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const [tasks, dispatch] = useImmerReducer(tasksReducer, initialTasks);</span><br></pre></td></tr></table></figure><h1 id="放大Reducer和Context的效果"><a href="#放大Reducer和Context的效果" class="headerlink" title="放大Reducer和Context的效果"></a>放大Reducer和Context的效果</h1><p><code>Reducer</code>可以抽离巩固状态更新逻辑，<code>Context</code>可以向深层次的子组件传递数据，这两者结合面对复杂的状态也能较好的管理。</p><h2 id="把Reducer和Context结合起来"><a href="#把Reducer和Context结合起来" class="headerlink" title="把Reducer和Context结合起来"></a>把Reducer和Context结合起来</h2><p>单独使用Reducer来管理状态时，如果遇到父子通信的场景，还是需要借助prop，如果组件嵌套层级过深，对于后期维护不太友好，这时可以搭配Context方便子组件获取数据。包含三个步骤：创建Context、把state和dispatch放入Context中、按需在子组件中使用Context。</p><h3 id="创建Context-1"><a href="#创建Context-1" class="headerlink" title="创建Context"></a>创建Context</h3><p><code>useReducer</code>会返回状态<code>tasks</code>和<code>dispatch</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);</span><br></pre></td></tr></table></figure><p>把他们分别传给两个Context：</p><ul><li><code>TasksContext</code>提供状态数组<code>tasks</code></li><li><code>TasksDispatchContext</code>提供一个函数使得组件能够dispatch行为。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// TasksContext.js</span><br><span class="line">import &#123; createContext &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export const TasksContext = createContext(null);</span><br><span class="line">export const TasksDispatchContext = createContext(null);</span><br></pre></td></tr></table></figure><h3 id="把状态和Context嵌入Context"><a href="#把状态和Context嵌入Context" class="headerlink" title="把状态和Context嵌入Context"></a>把状态和Context嵌入Context</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// App.js</span><br><span class="line">import &#123; TasksContext, TasksDispatchContext &#125; from &#x27;./TasksContext.js&#x27;;</span><br><span class="line"></span><br><span class="line">export default function TaskApp() &#123;</span><br><span class="line">  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);</span><br><span class="line">  // ...</span><br><span class="line">  return (</span><br><span class="line">    &lt;TasksContext.Provider value=&#123;tasks&#125;&gt;</span><br><span class="line">      &lt;TasksDispatchContext.Provider value=&#123;dispatch&#125;&gt;</span><br><span class="line">        &lt;h1&gt;Day off in Kyoto&lt;/h1&gt;</span><br><span class="line">        &lt;AddTask /&gt;</span><br><span class="line">        &lt;TaskList /&gt;</span><br><span class="line">      &lt;/TasksDispatchContext.Provider&gt;</span><br><span class="line">    &lt;/TasksContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按需在子组件中使用Context"><a href="#按需在子组件中使用Context" class="headerlink" title="按需在子组件中使用Context"></a>按需在子组件中使用Context</h3><p>上述示例中，会在<code>&lt;AddTask&gt;</code>和<code>&lt;TaskList&gt;</code>组件中用到Context，可以在这两个组件中按需使用Context。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// TaskList.js</span><br><span class="line">export default function TaskList() &#123;</span><br><span class="line">  const tasks = useContext(TasksContext);</span><br><span class="line">  // ...</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// AddTask.js</span><br><span class="line">export default function AddTask() &#123;</span><br><span class="line">  const [text, setText] = useState(&#x27;&#x27;);</span><br><span class="line">  const dispatch = useContext(TasksDispatchContext);</span><br><span class="line">  // ...</span><br><span class="line">  return (</span><br><span class="line">    // ...</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">      setText(&#x27;&#x27;);</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: &#x27;added&#x27;,</span><br><span class="line">        id: nextId++,</span><br><span class="line">        text: text,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;&#125;&gt;Add&lt;/button&gt;</span><br><span class="line">    // ...</span><br></pre></td></tr></table></figure><p>完成上述三个步骤后，组件状态更新的逻辑被单独抽离出来，且有良好的代码美观度。</p><h2 id="提取到一个文件中"><a href="#提取到一个文件中" class="headerlink" title="提取到一个文件中"></a>提取到一个文件中</h2><p>离散的操作虽然能让程序功能正常运行，但不利于后期统一维护，可以把这些整合到一个文件中。</p><p>例如把Context的provider封装成一个组件，使得父组件更加简洁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// TaskContext.js</span><br><span class="line">import &#123; createContext &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const TasksContext = createContext(null);</span><br><span class="line">const TasksDispatchContext = createContext(null);</span><br><span class="line"></span><br><span class="line">export function TasksProvider(&#123; children &#125;) &#123;</span><br><span class="line">  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;TasksContext.Provider value=&#123;tasks&#125;&gt;</span><br><span class="line">      &lt;TasksDispatchContext.Provider value=&#123;dispatch&#125;&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">      &lt;/TasksDispatchContext.Provider&gt;</span><br><span class="line">    &lt;/TasksContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useTasks() &#123;</span><br><span class="line">  return useContext(TasksContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useTasksDispatch() &#123;</span><br><span class="line">  return useContext(TasksDispatchContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function tasksReducer(tasks, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#x27;added&#x27;: &#123;</span><br><span class="line">      return [...tasks, &#123;</span><br><span class="line">        id: action.id,</span><br><span class="line">        text: action.text,</span><br><span class="line">        done: false</span><br><span class="line">      &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    case &#x27;changed&#x27;: &#123;</span><br><span class="line">      return tasks.map(t =&gt; &#123;</span><br><span class="line">        if (t.id === action.task.id) &#123;</span><br><span class="line">          return action.task;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return t;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    case &#x27;deleted&#x27;: &#123;</span><br><span class="line">      return tasks.filter(t =&gt; t.id !== action.id);</span><br><span class="line">    &#125;</span><br><span class="line">    default: &#123;</span><br><span class="line">      throw Error(&#x27;Unknown action: &#x27; + action.type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const initialTasks = [</span><br><span class="line">  &#123; id: 0, text: &#x27;Philosopher’s Path&#x27;, done: true &#125;,</span><br><span class="line">  &#123; id: 1, text: &#x27;Visit the temple&#x27;, done: false &#125;,</span><br><span class="line">  &#123; id: 2, text: &#x27;Drink matcha&#x27;, done: false &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// App.js</span><br><span class="line">import AddTask from &#x27;./AddTask.js&#x27;;</span><br><span class="line">import TaskList from &#x27;./TaskList.js&#x27;;</span><br><span class="line">import &#123; TasksProvider &#125; from &#x27;./TasksContext.js&#x27;;</span><br><span class="line"></span><br><span class="line">export default function TaskApp() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;TasksProvider&gt;</span><br><span class="line">      &lt;h1&gt;Day off in Kyoto&lt;/h1&gt;</span><br><span class="line">      &lt;AddTask /&gt;</span><br><span class="line">      &lt;TaskList /&gt;</span><br><span class="line">    &lt;/TasksProvider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a> <a href="/tags/React/" rel="tag"># React</a></div><div class="post-nav"><div class="post-nav-item"><a href="/83da8530/" rel="prev" title="跟着React官网学习2--增加交互性"><i class="fa fa-chevron-left"></i> 跟着React官网学习2--增加交互性</a></div><div class="post-nav-item"></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">f1ower1ang</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">25k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">1:30</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>