<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"f1ower1ang.top","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="本文记录React官网第二章相关内容，给页面增加交互性。"><meta property="og:type" content="article"><meta property="og:title" content="跟着React官网学习2--增加交互性"><meta property="og:url" content="https://f1ower1ang.top/83da8530/index.html"><meta property="og:site_name" content="f1ower1ang&#39;s blog"><meta property="og:description" content="本文记录React官网第二章相关内容，给页面增加交互性。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304231915563.png"><meta property="article:published_time" content="2023-04-23T09:32:58.000Z"><meta property="article:modified_time" content="2023-05-05T11:33:02.524Z"><meta property="article:author" content="f1ower1ang"><meta property="article:tag" content="前端"><meta property="article:tag" content="React"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304231915563.png"><link rel="canonical" href="https://f1ower1ang.top/83da8530/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://f1ower1ang.top/83da8530/","path":"83da8530/","title":"跟着React官网学习2--增加交互性"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>跟着React官网学习2--增加交互性 | f1ower1ang's blog</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">f1ower1ang's blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">花语的学习记录</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86%E4%BA%8B%E4%BB%B6"><span class="nav-text">响应处理事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="nav-text">事件冒泡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="nav-text">阻止默认行为</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%98%AF%E7%BB%84%E4%BB%B6%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-text">状态是组件的内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#React%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86State"><span class="nav-text">React如何管理State</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E5%B9%B6%E6%8F%90%E4%BA%A4"><span class="nav-text">渲染并提交</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E8%A7%A6%E5%8F%91"><span class="nav-text">渲染触发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="nav-text">组件渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E7%9B%B8%E5%85%B3%E5%8F%98%E5%8C%96%E8%BD%AC%E6%8D%A2%E4%B8%BADOM"><span class="nav-text">将相关变化转换为DOM</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E4%B9%9F%E4%B8%BA%E5%BF%AB%E7%85%A7"><span class="nav-text">状态也为快照</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%8A%B6%E6%80%81%E4%BC%9A%E8%A7%A6%E5%8F%91%E6%B8%B2%E6%9F%93"><span class="nav-text">设置状态会触发渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E4%BC%9A%E5%8F%8A%E6%97%B6%E8%8E%B7%E5%8F%96%E5%BF%AB%E7%85%A7"><span class="nav-text">渲染会及时获取快照</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E9%98%9F%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81"><span class="nav-text">排队更新状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">更新状态中的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8A%E7%8A%B6%E6%80%81%E8%A7%86%E4%B8%BA%E5%8F%AA%E8%AF%BB%E7%9A%84"><span class="nav-text">把状态视为只读的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1"><span class="nav-text">使用扩展运算符复制对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1"><span class="nav-text">更新嵌套对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Immer%E6%9D%A5%E7%AE%80%E5%8C%96%E6%9B%B4%E6%96%B0%E9%80%BB%E8%BE%91"><span class="nav-text">使用Immer来简化更新逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95%E4%B8%8D%E5%BB%BA%E8%AE%AE%E5%9C%A8React%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81"><span class="nav-text">为何不建议在React直接修改状态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-text">更新状态中的数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F%E6%9B%B4%E6%96%B0%E6%95%B0%E7%BB%84"><span class="nav-text">非侵入式更新数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%99%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-text">给数组添加元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-text">从数组中移除元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E5%8F%98%E6%8D%A2"><span class="nav-text">对数组进行变换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-text">修改数组中的某个元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E6%95%B0%E7%BB%84%E6%9F%90%E4%B8%80%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="nav-text">在数组某一位置插入元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%95%B0%E7%BB%84%E5%81%9A%E5%85%B6%E4%BB%96%E7%9A%84%E6%9B%B4%E6%94%B9"><span class="nav-text">对数组做其他的更改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">更新数组中的对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Immer%E7%AE%80%E5%8C%96%E6%9B%B4%E6%96%B0%E9%80%BB%E8%BE%91"><span class="nav-text">使用Immer简化更新逻辑</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="f1ower1ang" src="/uploads/avatar.png"><p class="site-author-name" itemprop="name">f1ower1ang</p><div class="site-description" itemprop="description">“静坐常思己过，闲聊莫论人非”</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://f1ower1ang.top/83da8530/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/uploads/avatar.png"><meta itemprop="name" content="f1ower1ang"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="f1ower1ang's blog"><meta itemprop="description" content="“静坐常思己过，闲聊莫论人非”"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="跟着React官网学习2--增加交互性 | f1ower1ang's blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">跟着React官网学习2--增加交互性</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-04-23 17:32:58" itemprop="dateCreated datePublished" datetime="2023-04-23T17:32:58+08:00">2023-04-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-05-05 19:33:02" itemprop="dateModified" datetime="2023-05-05T19:33:02+08:00">2023-05-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%B7%9F%E7%9D%80%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0React/" itemprop="url" rel="index"><span itemprop="name">跟着官网学习React</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>4.7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>17 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>本文记录React官网第二章相关内容，给页面增加交互性。</p></blockquote><span id="more"></span><h1 id="响应处理事件"><a href="#响应处理事件" class="headerlink" title="响应处理事件"></a>响应处理事件</h1><blockquote><p>我们可以给JSX添加事件处理器，以此给响应相关事件如点击、hover、输入框聚焦等事件。</p></blockquote><p>React中无论是HTML内置的标签还是自定义组件，事件处理器都是通过props来传递，再由子组件触发，这为一个完整流程。</p><p>因此，该过程主要分为两步：</p><ul><li>给子组件添加事件处理器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default function Button() &#123;</span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    alert(&#x27;You clicked me!&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子组件获取事件处理器并在合适时机调用</li></ul><p>​	对应HTML内置标签会自动执行，如上面代码中给<code>onClick</code>传入的<code>handleClick</code>方法会在按钮点击时自动执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Button(&#123; onClick, children &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;onClick&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">export default function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">  	&lt;div&gt;</span><br><span class="line">    	&lt;Button onClick=&#123;() =&gt; alert(&#x27;子组件按钮被点击&#x27;)&#125;&gt;子组件点击事件响应&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件完成子组件相关事件响应是通过props来完成的，即子组件的事件名对应于props对象的属性名，所以子组件的事件名可以语义化。</p><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>DOM事件流有三个阶段：事件捕获、目标、事件冒泡。默认为事件冒泡，即由目标元素开始响应事件，一级一级向上依次完成相应事件响应。</p><p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304231915563.png" alt="img"></p><p>在React中，会对事件处理函数传入一个事件对象作为参数，该对象中有一个方法<code>e.stopPropagation()</code>可以阻止事件冒泡。如果不想让事件冒泡，可以使用下面的方法阻止该行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Button(&#123; onClick, children &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;e =&gt; &#123;</span><br><span class="line">      e.stopPropagation();</span><br><span class="line">      onClick();</span><br><span class="line">    &#125;&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h2><p>内置的HTML标签中，有些事件存在默认行为（form中submit后会导致页面刷新），这些行为和事件冒泡是两回事。要阻止默认行为可以执行<code>e.preventDefault()</code>，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default function Signup() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit=&#123;e =&gt; &#123;</span><br><span class="line">      e.preventDefault();</span><br><span class="line">      alert(&#x27;Submitting!&#x27;);</span><br><span class="line">    &#125;&#125;&gt;</span><br><span class="line">      &lt;input /&gt;</span><br><span class="line">      &lt;button&gt;Send&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="状态是组件的内存"><a href="#状态是组件的内存" class="headerlink" title="状态是组件的内存"></a>状态是组件的内存</h1><blockquote><p>随着页面产生交互，组件也会变化，如输入表单信息、添加商品至购物车等行为，相应变化的数据也应被记住，这些变化的数据统称为组件的状态。</p></blockquote><p>React组件是函数式组件，每次组件渲染时都会重新执行函数，若使用局部变量还保存组件数据，则会在组件渲染时重新初始化，另外，修改局部变量不会触发组件重新渲染。React提供一个hook——<code>useState</code>，它返回一个数组，包含两个成员：</p><ul><li>一个是state变量，维护着最新的组件数据</li><li>一个是state setter函数，用于更新state变量并触发React重新渲染组件</li></ul><p><code>useState</code>使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;</span><br><span class="line">const [index, setIndex] = useState(0)</span><br><span class="line"></span><br><span class="line">// 更新index值</span><br><span class="line">setIndex(index + 1)</span><br><span class="line">// 或者（i为最新的index）</span><br><span class="line">setIndex(i =&gt; i + 1)</span><br></pre></td></tr></table></figure><h2 id="React如何管理State"><a href="#React如何管理State" class="headerlink" title="React如何管理State"></a>React如何管理State</h2><p>在使用<code>useState</code>时，除了设置初始值，没有其他标识符对状态进行标记。React以一种较为巧妙的方式完成，hooks在同一个组件渲染时会以稳定的顺序执行，在React内部，会为每个组件设置一个数组，用来保存<code>useState</code>返回值，下次组件渲染，再根据<code>useState</code>的执行顺序，返回对应数组子项。简易实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> componentHooks = [] <span class="comment">// 保存当前组件所有useState的返回值</span></span><br><span class="line"><span class="keyword">let</span> currentHookIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">initialState</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> pair = componentHooks[currentHookIndex] <span class="comment">// [state, setState]</span></span><br><span class="line">  <span class="keyword">if</span> (pair) &#123; <span class="comment">// 组件不是第一次渲染</span></span><br><span class="line">    currentHookIndex++</span><br><span class="line">    <span class="keyword">return</span> pair</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 组件首次渲染</span></span><br><span class="line">  pair = [initialState, setState]</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setState</span>(<span class="params">nextState</span>) &#123;</span><br><span class="line">    <span class="comment">// 值没有变化，不会触发视图更新</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">is</span>(nextState, pair[<span class="number">0</span>])) <span class="keyword">return</span></span><br><span class="line">    pair[<span class="number">0</span>] = nextState</span><br><span class="line">    <span class="comment">// 触发组件更新</span></span><br><span class="line">    <span class="title function_">updateDOM</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把useState返回值保存下来</span></span><br><span class="line">  componentHooks[currentHookIndex++] = pair</span><br><span class="line">  <span class="keyword">return</span> pair</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="渲染并提交"><a href="#渲染并提交" class="headerlink" title="渲染并提交"></a>渲染并提交</h1><blockquote><p>组件显示到屏幕之前需由React处理相关渲染过程，其主要包含三个步骤：触发渲染、渲染组件、提交转换为DOM</p></blockquote><h2 id="渲染触发"><a href="#渲染触发" class="headerlink" title="渲染触发"></a>渲染触发</h2><p>组件渲染的原因主要有两个：</p><ul><li><p>该组件是第一次渲染</p><ul><li>当app启动时，会触发组件的第一次渲染。该过程是调用根组件的<code>render</code>方法完成的，主要实现如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import Image from &#x27;./Image.js&#x27;;</span><br><span class="line">import &#123; createRoot &#125; from &#x27;react-dom/client&#x27;;</span><br><span class="line"></span><br><span class="line">// 把目标DOM节点转为根组件，后续组件将作为该节点的子节点渲染</span><br><span class="line">const root = createRoot(document.getElementById(&#x27;root&#x27;))</span><br><span class="line">// 初始触发渲染</span><br><span class="line">root.render(&lt;Image /&gt;);</span><br></pre></td></tr></table></figure></li><li><p>该组件或其祖先的状态被修改</p><ul><li>一旦组件初始化渲染，我们可以通过修改组件状态来触发其重新渲染。需要注意的是，组件状态的更改不会立刻引起组件重新渲染，React会将其放到队列排队等候，且这个过程是异步的。</li></ul></li></ul><h2 id="组件渲染"><a href="#组件渲染" class="headerlink" title="组件渲染"></a>组件渲染</h2><p>在触发渲染这个操作后，React会执行组件来了解展示的内容。<strong>“渲染”就是React执行组件</strong>。</p><ul><li>第一次渲染，React执行root组件的渲染函数</li><li>对于后续渲染，React执行组件状态变化的组件。</li></ul><p>组件渲染是递归的过程：如果更新后的组件返回其他组件，React将递归处理其子组件，直到当前组件没有嵌套其他组件。</p><p><strong>注意</strong>：函数组件的渲染必须是纯函数。</p><ul><li>相同的输入应返回相同的结果。即给函数组件传入相同的参数，返回的JSX也应相同的。</li><li>专注自己的业务。即不应该修改任何出现在渲染前阶段的变量。</li></ul><h2 id="将相关变化转换为DOM"><a href="#将相关变化转换为DOM" class="headerlink" title="将相关变化转换为DOM"></a>将相关变化转换为DOM</h2><p>React渲染组件后，会将组件的变化转换为DOM。</p><ul><li>第一次渲染，React将调用<code>appendChild()</code>来插入所有创建的DOM节点。</li><li>对于后续渲染，React将使用最少的操作（渲染时计算得来）使得DOM匹配最新的渲染结果。</li></ul><p><strong>React只修改两次渲染结果不一样的DOM节点</strong>。例如下面有一个组件，该组件会因为传入的props不一样而重新渲染，但是<code>input</code>元素的内容并不会改变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default function Clock(&#123; time &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">  	&lt;&gt;</span><br><span class="line">    	&lt;h1&gt;&#123;time&#125;&lt;/h1&gt;</span><br><span class="line">    	&lt;input /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="状态也为快照"><a href="#状态也为快照" class="headerlink" title="状态也为快照"></a>状态也为快照</h1><blockquote><p>状态不仅作为JS变量允许修改和读取，还能作为组件快照，记录组件更新前的信息。</p></blockquote><h2 id="设置状态会触发渲染"><a href="#设置状态会触发渲染" class="headerlink" title="设置状态会触发渲染"></a>设置状态会触发渲染</h2><p>当我们调用<code>useState()</code>返回的状态设置函数<code>setState</code>，如这里的<code>[state, setState] = useState(null)</code>，若状态发生变化(<code>Object.is()</code>判断)，它会触发组件的渲染，从而重新执行函数组件，获取最新的状态，但在组件刷新前并不会修改当前已有的状态。</p><h2 id="渲染会及时获取快照"><a href="#渲染会及时获取快照" class="headerlink" title="渲染会及时获取快照"></a>渲染会及时获取快照</h2><p>从函数组件返回的JSX就像是当前组件的快照，它的props、事件处理函数、局部变量等都是由渲染时的状态计算而来的，状态存在于函数组件之外。</p><p>这里可以举一个例子：每点击一次按钮，给一个数+3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">export default function Counter() &#123;</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;number&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">      &#125;&#125;&gt;+3&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而执行结果并不符合预期，这是因为执行<code>setNumber(number + 1)</code>并不会立即修改当前的<code>number</code>，假如当前<code>number=0</code>所以相当于执行了三次<code>setNumber(0 + 1)</code>。而这个<code>number</code>就相当于当前组件的快照，它会随着组件的重新渲染而更新。</p><p>更有趣的一个例子：每点击一次按钮，让<code>number+5</code>并3s后alert当前<code>number</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function Counter() &#123;</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;number&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setNumber(number + 5);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          alert(number);</span><br><span class="line">        &#125;, 3000);</span><br><span class="line">      &#125;&#125;&gt;+5&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：alert的结果是上一次组件更新前的数，如当前<code>number=0</code>，点击后，过了3s，<code>alert还是0</code>。由此可见，<strong>一次组件渲染对应一个状态变量值</strong>，这里也可以理解为<strong>闭包</strong>。</p><h1 id="排队更新状态"><a href="#排队更新状态" class="headerlink" title="排队更新状态"></a>排队更新状态</h1><blockquote><p>状态更新会引起组件重新渲染，React将依次处理，但有时我们需要在组件下一次渲染前对状态进行多个操作，并希望能根据最新状态来进行相关操作。</p></blockquote><p>之前我们知道组件中的状态保存着当前组件渲染的快照，因此调用状态的<code>setter</code>方法不会修改当前状态值信息，但有时批量修改状态需要根据最新的状态来完成，例如给一个状态<code>number+3</code>。前文提出，连续执行三次<code>setNumber(number+1)</code>并不能得到想要的结果。这时React允许我们给<code>setter</code>传入函数，诸如这种<code>setNumber(n =&gt; n + 1)</code>，传入的回调函数的参数就是最新的状态值，返回值作为要设置的状态值。</p><p>因此我们只需稍加修改一下点击事件处理函数，便可得到想要的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const handleClick = () =&gt; &#123;</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React会对其进行排队处理：</p><table><thead><tr><th align="center">queued update</th><th align="center"><code>n</code></th><th align="center">returns</th></tr></thead><tbody><tr><td align="center"><code>n =&gt; n + 1</code></td><td align="center"><code>0</code></td><td align="center"><code>0 + 1 = 1</code></td></tr><tr><td align="center"><code>n =&gt; n + 1</code></td><td align="center"><code>1</code></td><td align="center"><code>1 + 1 = 2</code></td></tr><tr><td align="center"><code>n =&gt; n + 1</code></td><td align="center"><code>2</code></td><td align="center"><code>2 + 1 = 3</code></td></tr></tbody></table><p>如果点击事件处理函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const handleClick = () =&gt; &#123;</span><br><span class="line">  setNumber(number + 5);</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的处理过程如下：</p><table><thead><tr><th align="center">queued update</th><th align="center"><code>n</code></th><th align="center">returns</th></tr></thead><tbody><tr><td align="center">“replace with <code>5</code>”</td><td align="center"><code>0</code> (未使用)</td><td align="center"><code>5</code></td></tr><tr><td align="center"><code>n =&gt; n + 1</code></td><td align="center"><code>5</code></td><td align="center"><code>5 + 1 = 6</code></td></tr></tbody></table><p>稍加改动一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const handleClick = () =&gt; &#123;</span><br><span class="line">  setNumber(number + 5);</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">  setNumber(42);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><table><thead><tr><th align="center">queued update</th><th align="center"><code>n</code></th><th align="center">returns</th></tr></thead><tbody><tr><td align="center">“replace with <code>5</code>”</td><td align="center"><code>0</code> (unused)</td><td align="center"><code>5</code></td></tr><tr><td align="center"><code>n =&gt; n + 1</code></td><td align="center"><code>5</code></td><td align="center"><code>5 + 1 = 6</code></td></tr><tr><td align="center">“replace with <code>42</code>”</td><td align="center"><code>6</code> (unused)</td><td align="center"><code>42</code></td></tr></tbody></table><p>因为最后一个<code>setter</code>，后续的结果始终为：<code>number=42</code></p><h1 id="更新状态中的对象"><a href="#更新状态中的对象" class="headerlink" title="更新状态中的对象"></a>更新状态中的对象</h1><blockquote><p>任何JS数据类型都能作为状态，包括对象。但如果要更新状态对象，需要先复制一份原始的，然后在其基础上修改，最终调用状态的setter方法。</p></blockquote><h2 id="把状态视为只读的"><a href="#把状态视为只读的" class="headerlink" title="把状态视为只读的"></a>把状态视为只读的</h2><p>不论是状态值类型为基础类型还是对象类型，我们都应该将其视为<strong>只读</strong>。</p><p>例如我们想要实现让一个圆点跟随鼠标移动，这里会定义一个状态对象来保存鼠标的坐标，然后设置圆点的<code>transform</code>属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">export default function MovingDot() &#123;</span><br><span class="line">  const [position, setPosition] = useState(&#123;</span><br><span class="line">    x: 0,</span><br><span class="line">    y: 0</span><br><span class="line">  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div</span><br><span class="line">      onPointerMove=&#123;e =&gt; &#123;</span><br><span class="line">        position.x = e.clientX;</span><br><span class="line">        position.y = e.clientY;</span><br><span class="line">      &#125;&#125;</span><br><span class="line">      style=&#123;&#123;</span><br><span class="line">        position: &#x27;relative&#x27;,</span><br><span class="line">        width: &#x27;100vw&#x27;,</span><br><span class="line">        height: &#x27;100vh&#x27;,</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">      &lt;div className=&quot;red-dot&quot; style=&#123;&#123;</span><br><span class="line">        transform: `translate($&#123;position.x&#125;px, $&#123;position.y&#125;px)`,</span><br><span class="line">      &#125;&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直觉来讲，可以直接修改<code>position</code>对象的属性值，但这样是不符合React设计规则的，且结果也没达到预期，其一是没有调用<code>setPosition</code>来更新状态，但这似乎没多大影响，个人猜想是两次渲染的<code>position</code>都相同，不会触发DOM更新。虽然有时候直接在原对象基础上修改能达到预期效果，但不建议这么做。</p><p>正确的做法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onPointerMove=&#123;e =&gt; &#123;</span><br><span class="line">  setPosition(&#123;</span><br><span class="line">    x: e.clientX,</span><br><span class="line">    y: e.clientY</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="使用扩展运算符复制对象"><a href="#使用扩展运算符复制对象" class="headerlink" title="使用扩展运算符复制对象"></a>使用扩展运算符复制对象</h2><p>在前一个例子中，<code>position</code>对象总是根据当前位置信息来更新，但通常来讲，我们不需要更新状态对象中所有属性，因此可以使用扩展运算符来复制原有属性，然后按需更新属性。</p><p>例如，对于一个<code>person</code>对象，我需要根据<code>input</code>来修改其邮箱，朴素做法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setPerson(&#123;</span><br><span class="line">  email: e.target.value, // New email from the input</span><br><span class="line">  lastName: person.lastName,</span><br><span class="line">  firstName: person.firstName</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也可以用扩展运算符<code>...</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setPerson(&#123;</span><br><span class="line">  ...person, // Copy the old fields</span><br><span class="line">  email: e.target.value // But override this one</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="更新嵌套对象"><a href="#更新嵌套对象" class="headerlink" title="更新嵌套对象"></a>更新嵌套对象</h2><p>有时候状态对象的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const [person, setPerson] = useState(&#123;</span><br><span class="line">  name: &#x27;Niki de Saint Phalle&#x27;,</span><br><span class="line">  artwork: &#123;</span><br><span class="line">    title: &#x27;Blue Nana&#x27;,</span><br><span class="line">    city: &#x27;Hamburg&#x27;,</span><br><span class="line">    image: &#x27;https://i.imgur.com/Sd1AgUOm.jpg&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果想更新<code>person.artwork.city</code>，通常我们会直接修改原有值 <code>person.artwork.city = &#39;New Delhi&#39;;</code>，但在React中这是不允许的，因此通常会使用以下方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const nextArtwork = &#123; ...person.artwork, city: &#x27;New Delhi&#x27; &#125;;</span><br><span class="line">const nextPerson = &#123; ...person, artwork: nextArtwork &#125;;</span><br><span class="line">setPerson(nextPerson);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setPerson(&#123;</span><br><span class="line">  ...person, // Copy other fields</span><br><span class="line">  artwork: &#123; // but replace the artwork</span><br><span class="line">    ...person.artwork, // with the same one</span><br><span class="line">    city: &#x27;New Delhi&#x27; // but in New Delhi!</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样显得比较繁琐，因此出现了第三方库<code>use-immer</code>来简化操作</p><h2 id="使用Immer来简化更新逻辑"><a href="#使用Immer来简化更新逻辑" class="headerlink" title="使用Immer来简化更新逻辑"></a>使用Immer来简化更新逻辑</h2><p>当前状态对象嵌套层级过深，更新操作反而成为体力活，有点本末倒置了。这里可以使用<code>use-immer</code>来简化相关操作，使得状态对象更新符合直觉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updatePerson(draft =&gt; &#123;</span><br><span class="line">  draft.artwork.city = &#x27;Lagos&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>Immer工作原理</strong>:</p><blockquote><p>Immer提供的参数(<code>draft</code>)是一种特殊类型的对象，称为代理，它可以“记录”在该对象上的操作。这就是为什么我们可以随心所欲地修改它的原因！在该引擎下，Immer可以知道<code>draft</code>对象的变化，并产生与之对应的全新对象。</p></blockquote><p><strong>Immer使用方式</strong>：</p><ul><li>执行<code>npm install use-immer</code>，将Immer添加到依赖库中</li><li>将<code>import &#123; useState &#125; from react</code>替换为<code>import &#123; useImmer &#125; from &#39;use-immer&#39;</code></li></ul><h2 id="为何不建议在React直接修改状态"><a href="#为何不建议在React直接修改状态" class="headerlink" title="为何不建议在React直接修改状态"></a>为何不建议在React直接修改状态</h2><ul><li><strong>调试</strong>：如果使用<code>console.log</code>并且不修改状态，那过去的日志就不会因为最近的状态更改而被破坏。因此，我们可以清楚地看到状态如何在渲染之间变化。</li><li><strong>优化</strong>：如果当前的props或state与下一个的相同，则常见的React优化策略依赖可以跳过。因为如果你从未修改过状态，那么这个检查过程是非常快的。只需判断<code>prevObj===obj</code>，就可以确定它内部没有任何更改。</li><li><strong>新功能</strong>：当前正在构建的React新功能依赖于将状态视为快照。如果改变状态，这可能会阻止我们使用React的新功能。</li><li><strong>需求更改</strong>：一些应用程序功能，如实现撤消&#x2F;恢复、显示、更改、历史记录，或允许用户将表单重置为以前的值，在没有任何变化的情况下更容易执行。这是因为我们可以将过去的状态副本保存在内存中，并在适当的时候重用它们。如果我们不按规则执行，像这样的功能以后可能很难添加。</li><li><strong>更简单的实现</strong>：因为React不依赖于状态直接修改，所以它不需要对对象做任何特殊的处理。不需要将它们封装到代理中来劫持它们的属性，也不需要像许多“响应式”解决方案那样在初始化时做其他工作。这也是为什么React允许我们将任何对象置于状态，无论对象有多大，都不会有额外的性能或陷阱。</li></ul><h1 id="更新状态中的数组"><a href="#更新状态中的数组" class="headerlink" title="更新状态中的数组"></a>更新状态中的数组</h1><blockquote><p>在JS中，数组是可以修改的，但在React将其作为状态因为视其为不可修改的。和对象一样，当我们想更新状态数组，需要复制一份，在副本上进行操作。</p></blockquote><h2 id="非侵入式更新数组"><a href="#非侵入式更新数组" class="headerlink" title="非侵入式更新数组"></a>非侵入式更新数组</h2><p>和对象一样，在React状态中我们应该把数组视为<strong>只读</strong>的。每次更新状态数组时，我们需要给状态的<code>setter</code>方法传入新的数组，可以通过数组方法中相关方法生成副本如<code>filter()</code>和<code>map()</code>。</p><p>数组的成员方法中分为两类：会更改原数组、不更改原数组。</p><table><thead><tr><th></th><th>avoid (mutates the array)</th><th>prefer (returns a new array)</th></tr></thead><tbody><tr><td>adding</td><td><code>push</code>, <code>unshift</code></td><td><code>concat</code>, <code>[...arr]</code> spread syntax (<a target="_blank" rel="noopener" href="https://react.dev/learn/updating-arrays-in-state#adding-to-an-array">example</a>)</td></tr><tr><td>removing</td><td><code>pop</code>, <code>shift</code>, <code>splice</code></td><td><code>filter</code>, <code>slice</code> (<a target="_blank" rel="noopener" href="https://react.dev/learn/updating-arrays-in-state#removing-from-an-array">example</a>)</td></tr><tr><td>replacing</td><td><code>splice</code>, <code>arr[i] = ...</code> assignment</td><td><code>map</code> (<a target="_blank" rel="noopener" href="https://react.dev/learn/updating-arrays-in-state#replacing-items-in-an-array">example</a>)</td></tr><tr><td>sorting</td><td><code>reverse</code>, <code>sort</code></td><td>copy the array first (<a target="_blank" rel="noopener" href="https://react.dev/learn/updating-arrays-in-state#making-other-changes-to-an-array">example</a>)</td></tr></tbody></table><h2 id="给数组添加元素"><a href="#给数组添加元素" class="headerlink" title="给数组添加元素"></a>给数组添加元素</h2><p><code>push()</code>会更改原数组，因此我们可以使用扩展运算符<code>...</code>来拷贝原数组，然后在根据需求在数组的头或尾添加元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 数组尾追加</span><br><span class="line">setArtists(</span><br><span class="line">  [ // with a new array</span><br><span class="line">    ...artists, // that contains all the old items</span><br><span class="line">    &#123; id: nextId++, name: name &#125; // and one new item at the end</span><br><span class="line">  ]</span><br><span class="line">);</span><br><span class="line">// 数组头插入</span><br><span class="line">setArtists([</span><br><span class="line">  &#123; id: nextId++, name: name &#125;,</span><br><span class="line">  ...artists // Put old items at the end</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h2 id="从数组中移除元素"><a href="#从数组中移除元素" class="headerlink" title="从数组中移除元素"></a>从数组中移除元素</h2><p>可以使用<code>filter()</code>方法将不需要的元素过滤掉，等价于从数组中移除某个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const removeArtist = (artist) =&gt; &#123;</span><br><span class="line">  setArtists(</span><br><span class="line">  	artists.filter(a =&gt; a.id !== artist.id)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对数组进行变换"><a href="#对数组进行变换" class="headerlink" title="对数组进行变换"></a>对数组进行变换</h2><p>如果要对数组的部分或所有元素进行批量修改，可以使用<code>map()</code>方法批量操作，它会返回新的数组。</p><p>例如，每点击一次按钮，只让圆点向下移动，方块不动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">let initialShapes = [</span><br><span class="line">  &#123; id: 0, type: &#x27;circle&#x27;, x: 50, y: 100 &#125;,</span><br><span class="line">  &#123; id: 1, type: &#x27;square&#x27;, x: 150, y: 100 &#125;,</span><br><span class="line">  &#123; id: 2, type: &#x27;circle&#x27;, x: 250, y: 100 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export default function ShapeEditor() &#123;</span><br><span class="line">  const [shapes, setShapes] = useState(</span><br><span class="line">    initialShapes</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    const nextShapes = shapes.map(shape =&gt; &#123;</span><br><span class="line">      if (shape.type === &#x27;square&#x27;) &#123;</span><br><span class="line">        // No change</span><br><span class="line">        return shape;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // Return a new circle 50px below</span><br><span class="line">        return &#123;</span><br><span class="line">          ...shape,</span><br><span class="line">          y: shape.y + 50,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // Re-render with the new array</span><br><span class="line">    setShapes(nextShapes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        Move circles down!</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &#123;shapes.map(shape =&gt; (</span><br><span class="line">        &lt;div</span><br><span class="line">          key=&#123;shape.id&#125;</span><br><span class="line">          style=&#123;&#123;</span><br><span class="line">          background: &#x27;purple&#x27;,</span><br><span class="line">          position: &#x27;absolute&#x27;,</span><br><span class="line">          left: shape.x,</span><br><span class="line">          top: shape.y,</span><br><span class="line">          borderRadius:</span><br><span class="line">            shape.type === &#x27;circle&#x27;</span><br><span class="line">              ? &#x27;50%&#x27; : &#x27;&#x27;,</span><br><span class="line">          width: 20,</span><br><span class="line">          height: 20,</span><br><span class="line">        &#125;&#125; /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改数组中的某个元素"><a href="#修改数组中的某个元素" class="headerlink" title="修改数组中的某个元素"></a>修改数组中的某个元素</h2><p>同样可以借助<code>map()</code>方法，只对某个下标的元素进行变化，其他不变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function handleIncrementClick(index) &#123;</span><br><span class="line">    const nextCounters = counters.map((c, i) =&gt; &#123;</span><br><span class="line">      if (i === index) &#123;</span><br><span class="line">        // Increment the clicked counter</span><br><span class="line">        return c + 1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // The rest haven&#x27;t changed</span><br><span class="line">        return c;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    setCounters(nextCounters);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="在数组某一位置插入元素"><a href="#在数组某一位置插入元素" class="headerlink" title="在数组某一位置插入元素"></a>在数组某一位置插入元素</h2><p>这里可以将扩展运算符<code>...</code>和<code>slice()</code>方法搭配使用。</p><p>例如，我想在数组下标为1的地方插入一个元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function insertArtist(artist) &#123;</span><br><span class="line">  const insertAt = 1; // Could be any index</span><br><span class="line">    const nextArtists = [</span><br><span class="line">      // Items before the insertion point:</span><br><span class="line">      ...artists.slice(0, insertAt),</span><br><span class="line">      // New item:</span><br><span class="line">      artist,</span><br><span class="line">      // Items after the insertion point:</span><br><span class="line">      ...artists.slice(insertAt)</span><br><span class="line">    ];</span><br><span class="line">    setArtists(nextArtists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对数组做其他的更改"><a href="#对数组做其他的更改" class="headerlink" title="对数组做其他的更改"></a>对数组做其他的更改</h2><p>有时候，只使用<code>map()</code>和<code>filter()</code>方法并不能完成相关操作，例如对数组进行翻转、排序等。这时，我们可以先拷贝原数组，然后在其基础上做相关操作。</p><p>例如，我们对数组进行翻转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function reverseList() &#123;</span><br><span class="line">  const nextList = [...list]</span><br><span class="line">  nextList.reverse()</span><br><span class="line">  setList(nextList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改数组某项元素也是同理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const nextList = [...list];</span><br><span class="line">nextList[0].seen = true; // Problem: mutates list[0]</span><br><span class="line">setList(nextList);</span><br></pre></td></tr></table></figure><h2 id="更新数组中的对象"><a href="#更新数组中的对象" class="headerlink" title="更新数组中的对象"></a>更新数组中的对象</h2><p><code>slice()</code>和扩展运算符<code>...</code>为浅拷贝，当我们使用同一个数组（元素均为对象）给不同状态初始化时，如果在元素上直接修改，会影响其他状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">let nextId = 3;</span><br><span class="line">const initialList = [</span><br><span class="line">  &#123; id: 0, title: &#x27;Big Bellies&#x27;, seen: false &#125;,</span><br><span class="line">  &#123; id: 1, title: &#x27;Lunar Landscape&#x27;, seen: false &#125;,</span><br><span class="line">  &#123; id: 2, title: &#x27;Terracotta Army&#x27;, seen: true &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const [myList, setMyList] = useState(initialList)</span><br><span class="line">const [yourList, setYourList] = useState(initialList)</span><br></pre></td></tr></table></figure><p>如果直接这样操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const myNextList = [...myList];</span><br><span class="line">const artwork = myNextList.find(a =&gt; a.id === artworkId);</span><br><span class="line">artwork.seen = nextSeen; // Problem: mutates an existing item</span><br><span class="line">setMyList(myNextList);</span><br></pre></td></tr></table></figure><p><code>yourList</code>也会受影响，正确的方法应使用新的对象覆盖，例如可以使用<code>map()</code>进行相关操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setMyList(myList.map(artwork =&gt; &#123;</span><br><span class="line">  if (artwork.id === artworkId) &#123;</span><br><span class="line">    // Create a *new* object with changes</span><br><span class="line">    return &#123; ...artwork, seen: nextSeen &#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // No changes</span><br><span class="line">    return artwork;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h2 id="使用Immer简化更新逻辑"><a href="#使用Immer简化更新逻辑" class="headerlink" title="使用Immer简化更新逻辑"></a>使用Immer简化更新逻辑</h2><p>和对象一样，我们可以使用<code>Immer</code>来简化数组的更新操作，使其更符合逻辑。</p><p>使用<code>Immer</code>更新数组中的对象将变得更加简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const [myList, updateMyList] = useImmer(</span><br><span class="line">  initialList</span><br><span class="line">);</span><br><span class="line">const [yourList, updateYourList] = useImmer(</span><br><span class="line">  initialList</span><br><span class="line">);</span><br><span class="line">// 更新myList</span><br><span class="line">updateMyList(draft =&gt; &#123;</span><br><span class="line">  const artwork = draft.find(a =&gt; a.id === id);</span><br><span class="line">  artwork.seen = nextSeen;</span><br><span class="line">&#125;);</span><br><span class="line">// 更新yourList</span><br><span class="line">updateYourList(draft =&gt; &#123;</span><br><span class="line">  const artwork = draft.find(a =&gt; a.id === id);</span><br><span class="line">  artwork.seen = nextSeen;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a> <a href="/tags/React/" rel="tag"># React</a></div><div class="post-nav"><div class="post-nav-item"><a href="/d7b48b88/" rel="prev" title="从0到1写一个接口"><i class="fa fa-chevron-left"></i> 从0到1写一个接口</a></div><div class="post-nav-item"></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">f1ower1ang</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">20k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">1:13</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>