<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS常见手写题</title>
    <url>/f226bd05/</url>
    <content><![CDATA[<blockquote>
<p>对JS中常见的API以及其内部实现原理重新实现一遍，知其所以然才能灵活的使用它们。</p>
</blockquote>
<span id="more"></span>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="解析-URL-参数为对象"><a href="#解析-URL-参数为对象" class="headerlink" title="解析 URL 参数为对象"></a>解析 URL 参数为对象</h2><p>例如，<code>http://www.xxx.com?ids=123&amp;&amp;ids=456&amp;name=jack&amp;male</code>会被转化为<code>&#123; ids: [123, 456], name: &#39;jack&#39;, male: true &#125;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseParam</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)/</span>.<span class="title function_">exec</span>(url)[<span class="number">1</span>] <span class="comment">// 将 ? 后面的字符串取出来</span></span><br><span class="line">  <span class="keyword">const</span> paramsArr = paramsStr.<span class="title function_">split</span>(<span class="string">&#x27;&amp;&#x27;</span>) <span class="comment">// 将字符串以 &amp; 分割后存到数组中</span></span><br><span class="line">  <span class="keyword">const</span> paramsObj = &#123;&#125;</span><br><span class="line">  <span class="comment">// 将 params 存到对象中</span></span><br><span class="line">  paramsArr.<span class="title function_">forEach</span>(<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/=/</span>.<span class="title function_">test</span>(param)) &#123; <span class="comment">// 处理有 value 的参数</span></span><br><span class="line">      <span class="keyword">let</span> [key, val] = param.<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>) <span class="comment">// 分割 key 和 value</span></span><br><span class="line">      val = <span class="built_in">decodeURIComponent</span>(val) <span class="comment">// 解码</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(val)) val = <span class="title class_">Number</span>(val) <span class="comment">// 判断是否转为数字</span></span><br><span class="line">      <span class="keyword">if</span> (paramsObj.<span class="title function_">hasOwnProperty</span>(key)) <span class="comment">// 如果对象有 key，则添加一个值</span></span><br><span class="line">        paramsObj[key] = [].<span class="title function_">concat</span>(paramsObj[key], val)</span><br><span class="line">      <span class="keyword">else</span> <span class="comment">// 如果对象没有这个 key，创建 key 并设置值</span></span><br><span class="line">        paramsObj[key] = val</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="comment">// 处理没有 value 的参数</span></span><br><span class="line">      paramsObj[param] = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> paramsObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写instanceof方法"><a href="#手写instanceof方法" class="headerlink" title="手写instanceof方法"></a>手写instanceof方法</h2><p>Instanceof 原理就是判断当前对象的隐式原型(<code>__proto__</code>)是否等于构造函数的原型(<code>prototype</code>)，若不是则顺着原型链查找，直到为<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">obj, constructor</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeof</span>(obj), prototype = constructor.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写new操作符"><a href="#手写new操作符" class="headerlink" title="手写new操作符"></a>手写new操作符</h2><p>new操作符的原理为：创建一个空对象，并把该对象的隐式原型指向构造函数的原型对象，然后执行构造函数并通过显示绑定改变构造函数里的this指向，从而为空对象添加属性，最后判断构造函数是否返回一个对象，若是则将其作为返回值，若没有则返回新建的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">constructor, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  <span class="keyword">const</span> result = constructor.<span class="title function_">apply</span>(obj, args)</span><br><span class="line">  <span class="keyword">if</span> (result !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> result</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写Promise-all"><a href="#手写Promise-all" class="headerlink" title="手写Promise.all"></a>手写Promise.all</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promiseAll</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="comment">// 先判断传入的参数是否为可迭代的</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> promises[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] !== <span class="string">&#x27;function&#x27;</span>) </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;argument must be an array&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promises.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        cnt++</span><br><span class="line">        result[index] = res</span><br><span class="line">        <span class="keyword">if</span> (cnt === promises.<span class="property">length</span>) <span class="title function_">resolve</span>(result)</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写防抖函数"><a href="#手写防抖函数" class="headerlink" title="手写防抖函数"></a>手写防抖函数</h2><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait, immediate</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer)</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    <span class="keyword">let</span> callNow = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (immedaite) callNow = !timer</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!immediate) fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;, wait)</span><br><span class="line">    <span class="keyword">if</span> (callNow) fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写节流函数"><a href="#手写节流函数" class="headerlink" title="手写节流函数"></a>手写节流函数</h2><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">if</span> (now - pre &gt;= delay) &#123;</span><br><span class="line">      pre = now</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写-call、apply、bind-函数"><a href="#手写-call、apply、bind-函数" class="headerlink" title="手写 call、apply、bind 函数"></a>手写 call、apply、bind 函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context=<span class="variable language_">window</span>, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;not function&#x27;</span>)</span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context=<span class="variable language_">window</span>, args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;not function&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (args &amp;&amp; !<span class="title class_">Array</span>.<span class="title function_">isArray</span>(args)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;not array&#x27;</span>)</span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context, ...args1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;not function&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fNOP</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fBound</span>(<span class="params">...args2</span>) &#123;</span><br><span class="line">		<span class="comment">// 判断是否被用作构造函数</span></span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> fBound ? <span class="variable language_">this</span> : context, args1.<span class="title function_">contact</span>(args2))</span><br><span class="line">  &#125;</span><br><span class="line">  fNop.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>()</span><br><span class="line">  fBound.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = fBound</span><br><span class="line">  <span class="keyword">return</span> fBound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现Ajax请求"><a href="#实现Ajax请求" class="headerlink" title="实现Ajax请求"></a>实现Ajax请求</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">        <span class="comment">// 1. 新建一个HTTP对象</span></span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>)</span><br><span class="line">        <span class="comment">// 2. 设置状态监听函数 </span></span><br><span class="line">        <span class="comment">// (一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件)</span></span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line">            <span class="comment">// 3. 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>)</span><br><span class="line">            <span class="keyword">else</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置错误监听函数</span></span><br><span class="line">        xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">        xhr.<span class="property">responseType</span> = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">        <span class="comment">// 设置请求头信息</span></span><br><span class="line">        xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">        <span class="comment">// 发送 HTTP 请求</span></span><br><span class="line">        xhr.<span class="title function_">send</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现深浅拷贝"><a href="#实现深浅拷贝" class="headerlink" title="实现深浅拷贝"></a>实现深浅拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> value !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(value) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.<span class="title function_">hasOwnProperty</span>(key)) res[key] = value[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map 用来解决循环引用问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">value, map = <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;symbol&#x27;</span>) <span class="keyword">return</span> <span class="title class_">Symbol</span>(value.<span class="property">description</span>)</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="literal">null</span> || <span class="keyword">typeof</span> value !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Set</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Set</span>([...value])</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Map</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Map</span>([...value])</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">has</span>(value)) <span class="keyword">return</span> map.<span class="title function_">get</span>(value)</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(value) ? [] : &#123;&#125;</span><br><span class="line">    map.<span class="title function_">set</span>(value, res)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.<span class="title function_">hasOwnProperty</span>(key))</span><br><span class="line">            res[key] = <span class="title function_">deepClone</span>(value[key], map)</span><br><span class="line">    <span class="comment">// Symbol key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> value.<span class="title function_">getOwnPropertySymbols</span>(value)) &#123;</span><br><span class="line">        res[key] = <span class="title function_">deepClone</span>(value[key], map)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fNOP</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    fNOP.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> prototype = <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第2、3、8行可由 Child.prototype = Object.create(Parent.prototype) 替代</span></span><br><span class="line">    <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> prototype) &#123;</span><br><span class="line">        <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>[key] = prototype[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数自动柯理化"><a href="#函数自动柯理化" class="headerlink" title="函数自动柯理化"></a>函数自动柯理化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> argLen = fn.<span class="property">length</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.<span class="property">length</span> &lt; argLen)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> curried.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args.<span class="title function_">concat</span>(args2))</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curried</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="title function_">currying</span>(add)</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h1 id="EventMitter"><a href="#EventMitter" class="headerlink" title="EventMitter"></a>EventMitter</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  private <span class="attr">_events</span>: <span class="title class_">Record</span>&lt;string, <span class="title class_">Array</span>&lt;<span class="title class_">Function</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_events</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">evt: string, ...args: any[]</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_events</span>[evt]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fns = [...<span class="variable language_">this</span>.<span class="property">_events</span>[evt]];</span><br><span class="line">    fns.<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">evt: string, fn: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;The evet-triggered callback must be a function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_events</span>[evt]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_events</span>[evt] = [fn];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_events</span>[evt].<span class="title function_">push</span>(fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">once</span>(<span class="params">evt: string, fn: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">execFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">off</span>(evt, execFn);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(evt, execFn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">evt: string, fn?: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_events</span>[evt]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_events</span>[evt] &amp;&amp; (<span class="variable language_">this</span>.<span class="property">_events</span>[evt].<span class="property">length</span> = <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cb;</span><br><span class="line">    <span class="keyword">const</span> cbLen = <span class="variable language_">this</span>.<span class="property">_events</span>[evt].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbLen; i++) &#123;</span><br><span class="line">      cb = <span class="variable language_">this</span>.<span class="property">_events</span>[evt][i];</span><br><span class="line">      <span class="keyword">if</span> (cb === fn) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_events</span>[evt].<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">removeAllListeners</span>(<span class="params">evt?: string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (evt) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_events</span>[evt] &amp;&amp; (<span class="variable language_">this</span>.<span class="property">_events</span>[evt].<span class="property">length</span> = <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_events</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h2 id="数组的乱序输出"><a href="#数组的乱序输出" class="headerlink" title="数组的乱序输出"></a>数组的乱序输出</h2><p>主要的实现思路就是：</p>
<ul>
<li>取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。</li>
<li>第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换</li>
<li>按照上面的规律执行，直到遍历完成</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">randomArray</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = arr.<span class="property">length</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">random</span>() * (n - i - <span class="number">1</span>) + i</span><br><span class="line">        [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据扁平化"><a href="#数据扁平化" class="headerlink" title="数据扁平化"></a>数据扁平化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i])</span><br><span class="line">            res.<span class="title function_">concat</span>(<span class="title function_">flatten</span>(arr[i]))</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce 函数迭代</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        pre.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? <span class="title function_">flatten</span>(cur) : cur)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line">        arr = [].<span class="title function_">concat</span>(...arr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 flat   arr.flat(Infinity)</span></span><br><span class="line"><span class="comment">// 正则和JSON方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr)</span><br><span class="line">    str = str.<span class="title function_">replace</span>(<span class="regexp">/\[|\]/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    str = <span class="string">&#x27;[&#x27;</span> + str + <span class="string">&#x27;]&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="列表转成树形结构"><a href="#列表转成树形结构" class="headerlink" title="列表转成树形结构"></a>列表转成树形结构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换前：</span></span><br><span class="line">source = [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;body&#x27;</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;title&#x27;</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;div&#x27;</span></span><br><span class="line">          &#125;]</span><br><span class="line"><span class="comment">// 转换为: </span></span><br><span class="line">tree = [&#123;</span><br><span class="line">          <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">pid</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">              <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">              <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;div&#x27;</span></span><br><span class="line">            &#125;]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">listToTree</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(data)) <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    data.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        map.<span class="title function_">set</span>(item.<span class="property">id</span>, item)</span><br><span class="line">    &#125;)</span><br><span class="line">    data.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">has</span>(item.<span class="property">pid</span>)) &#123;</span><br><span class="line">            <span class="keyword">const</span> parent = map.<span class="title function_">get</span>(item.<span class="property">pid</span>)</span><br><span class="line">            (parent.<span class="property">children</span> || parent.<span class="property">children</span> = []).<span class="title function_">push</span>(item)</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            result.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树形结构转成列表"><a href="#树形结构转成列表" class="headerlink" title="树形结构转成列表"></a>树形结构转成列表</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">treeToList</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    </span><br><span class="line">    data.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">children</span> &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item.<span class="property">children</span>)) &#123;</span><br><span class="line">            result.<span class="title function_">concat</span>(<span class="title function_">treeToList</span>(item.<span class="property">children</span>))</span><br><span class="line">            <span class="keyword">delete</span> item.<span class="property">children</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数字每千分位用逗号隔开"><a href="#数字每千分位用逗号隔开" class="headerlink" title="数字每千分位用逗号隔开"></a>数字每千分位用逗号隔开</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">format</span> = (<span class="params">num</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> str = num.<span class="title function_">toString</span>(), float = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (str.<span class="title function_">indexOf</span>(<span class="string">&#x27;.&#x27;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">        [str, float] = str.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    str = str.<span class="title function_">replace</span>(<span class="regexp">/(\d)(?=((\d&#123;3&#125;)+)$)/g</span>, <span class="string">&#x27;$1,&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (float.<span class="property">length</span>) <span class="keyword">return</span> str + <span class="string">&#x27;.&#x27;</span> + float</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="场景应用"><a href="#场景应用" class="headerlink" title="场景应用"></a>场景应用</h1><h2 id="循环打印红黄绿"><a href="#循环打印红黄绿" class="headerlink" title="循环打印红黄绿"></a>循环打印红黄绿</h2><p><strong>红灯 3s 亮一次，绿灯 2s 亮一次，黄灯 1s 亮一次，交替重复</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">task</span> = (<span class="params">timer, light</span>) =&gt; </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (light === <span class="string">&#x27;red&#x27;</span>) &#123;</span><br><span class="line">                <span class="title function_">red</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (light === <span class="string">&#x27;green&#x27;</span>) &#123;</span><br><span class="line">                <span class="title function_">green</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (light === <span class="string">&#x27;yellow&#x27;</span>) &#123;</span><br><span class="line">                <span class="title function_">yellow</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">        &#125;, timer)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">step</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">task</span>(<span class="number">3000</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">task</span>(<span class="number">2000</span>, <span class="string">&#x27;green&#x27;</span>))</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">task</span>(<span class="number">1000</span>, <span class="string">&#x27;yellow&#x27;</span>))</span><br><span class="line">        .<span class="title function_">then</span>(step)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">step</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// async await</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">taskRunner</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">task</span>(<span class="number">3000</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">task</span>(<span class="number">2000</span>, <span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">task</span>(<span class="number">1000</span>, <span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">    <span class="title function_">taskRunner</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">taskRunner</span>()</span><br></pre></td></tr></table></figure>

<h2 id="Jsonp"><a href="#Jsonp" class="headerlink" title="Jsonp"></a>Jsonp</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">src</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">callback</span> = <span class="keyword">function</span>(<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(data)</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(script)</span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">window</span>.<span class="property">callback</span></span><br><span class="line">        &#125;</span><br><span class="line">        src += <span class="string">&#x27;callback=callback&#x27;</span></span><br><span class="line">        <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">        script.<span class="property">src</span> = src</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS手写</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack设计理念及有关实现</title>
    <url>/213a89b2/</url>
    <content><![CDATA[<blockquote>
<p>前端工程化中，构建工具是核心，虽然目前已经有许多构建工具如vite、esbuild等，但由于webpack周边完善的生态，它仍然是一个主流的JS打包工具。为了更好的了解webpack，本文将依据webpack构建流程来实现一个简易的demo。</p>
</blockquote>
<span id="more"></span>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><blockquote>
<p>初始化项目</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pnpm init <span class="comment">// 使用pnpm初始化一个项目</span></span><br><span class="line">pnpm install webpack <span class="comment">// 安装依赖</span></span><br></pre></td></tr></table></figure>

<p>初始化完依赖后，可以按照以下目录结构添加文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">├── node_modules</span><br><span class="line">├── package-lock.<span class="property">json</span></span><br><span class="line">├── package.<span class="property">json</span></span><br><span class="line">├── webpack.<span class="property">config</span>.<span class="property">js</span> #配置文件</span><br><span class="line">├── <span class="keyword">debugger</span>.<span class="property">js</span> #测试文件</span><br><span class="line">└── src # 源码目录</span><br><span class="line">     |── index.<span class="property">js</span></span><br><span class="line">     |── name.<span class="property">js</span></span><br><span class="line">     └── age.<span class="property">js</span></span><br></pre></td></tr></table></figure>

<p><strong>webpack.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义plugin</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebpackRunPlugin</span> &#123;</span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">        compiler.<span class="property">hooks</span>.<span class="property">run</span>.<span class="title function_">tap</span>(<span class="string">&#x27;WebpackRunPlugin&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始编译&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebpackDonePlugin</span> &#123;</span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">        compiler.<span class="property">hooks</span>.<span class="property">done</span>.<span class="title function_">tap</span>(<span class="string">&#x27;WebpackDonePlugin&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束编译&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义loader</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">loader1</span> = (<span class="params">source</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> source + <span class="string">&#x27;//给你的代码加点注释：loader1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">loader2</span> = (<span class="params">source</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> source + <span class="string">&#x27;//给你的代码加点注释：loader2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 防止代码被压缩</span></span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">// 入口文件</span></span><br><span class="line">    <span class="attr">module</span>: &#123; <span class="comment">// 使用自定义loader</span></span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [loader1, loader2]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [ <span class="comment">// 使用自定义插件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WebpackRunPlugin</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WebpackDonePlugin</span>()</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">output</span>: &#123; <span class="comment">// 打包文件输出路径</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;index.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">require</span>(<span class="string">&#x27;./name&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> age = <span class="built_in">require</span>(<span class="string">&#x27;./age&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;entry文件打印作者信息&#x27;</span>, name, age)</span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;name.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="string">&#x27;f1ower1ang&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;age.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="string">&#x27;88&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>依赖关系</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/WX20230404.png" alt="WX20230404"></p>
<p>Wepback是一个函数，返回值是Compiler对象，该函数主要完成两件事情：初始化Compiler对象、注册插件。随后调用compiler的run方法开始编译，该方法接收一个回调，用来查看编译过程中的错误信息或编译信息。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/image-20230404215023692.png" alt="image-20230404215023692"></p>
<p><strong>debugger.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; webpack &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpackOptions = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = <span class="title function_">webpack</span>(webpackOptions)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始编译</span></span><br><span class="line">compiler.<span class="title function_">run</span>(<span class="function">(<span class="params">err, stats</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">        stats.<span class="title function_">toJson</span>(&#123;</span><br><span class="line">            <span class="attr">assets</span>: <span class="literal">true</span>, <span class="comment">// 打印本次编译产出的资源</span></span><br><span class="line">            <span class="attr">chunks</span>: <span class="literal">true</span>, <span class="comment">// 打印本次编译产出的代码块</span></span><br><span class="line">            <span class="attr">modules</span>: <span class="literal">true</span> <span class="comment">// 打印本次编译产出的模块</span></span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行debugger文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node ./debugger.js</span><br></pre></td></tr></table></figure>

<p>得到打包后的文件 <strong>dist&#x2F;main.js</strong> (已对原文件内容进行美化)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> modules = &#123;</span><br><span class="line">    <span class="string">&#x27;./src/name.js&#x27;</span>: <span class="function">(<span class="params"><span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="string">&#x27;f1ower1ang&#x27;</span> <span class="comment">//给你的代码加点注释：loader2//给你的代码加点注释：loader1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;./src/age.js&#x27;</span>: <span class="function">(<span class="params"><span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="string">&#x27;88&#x27;</span> <span class="comment">//给你的代码加点注释：loader2//给你的代码加点注释：loader1</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">require</span>(<span class="params">moduleId</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cachedModule = modules[moduleId]</span><br><span class="line">    <span class="keyword">if</span> (cachedModule) <span class="keyword">return</span> cachedModule.<span class="property">exports</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable language_">module</span> = (cache[moduleId] = &#123;</span><br><span class="line">      <span class="attr">exports</span>: &#123;&#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    modules[moduleId](<span class="variable language_">module</span>, <span class="variable language_">module</span>.<span class="property">exports</span>, <span class="built_in">require</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="built_in">require</span>(<span class="string">&#x27;./src/name.js&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> age = <span class="built_in">require</span>(<span class="string">&#x27;./src/age.js&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;entry文件打印作者信息&#x27;</span>, name, age);</span><br><span class="line">  <span class="comment">//给你的代码加点注释：loader2//给你的代码加点注释：loader1</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h1><p>在正式实现相关核心流程之前，先重温一下Webpack的构建流程，后续也是基于该流程来完成核心流程中的代码实现：</p>
<ol>
<li><p><strong>初始化参数</strong>：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。</p>
</li>
<li><p><strong>开始编译</strong>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译。</p>
<ul>
<li>插件系统使得Webpack的扩展性强，是一种可插拔式的设计。它本质上是一种事件流的机制，到了固定时间节点就广播特定的事件，核心是发布订阅机制，基于 tapable。</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/image-20230404221855938.png" alt="image-20230404221855938"></p>
</li>
<li><p><strong>确定入口</strong>：根据配置中的 entry 找出所有的入口文件。</p>
</li>
<li><p><strong>编译模块</strong>：从入口文件出发,调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</p>
<ul>
<li>本质上Webpack只能识别js文件，对于其他格式的文件需要将其转换为js代码才能被执行，而这个转换过程就交给loader来完成，换言之，loader充当者一个翻译官的角色。</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/image-20230404220330561.png" alt="image-20230404220330561"></p>
</li>
<li><p><strong>完成模块编译</strong>：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</p>
</li>
<li><p><strong>输出资源</strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。</p>
</li>
<li><p><strong>输出完成</strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p>
</li>
</ol>
<h1 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h1><p>Webpack构建流程可以简单概括为以下几个阶段：</p>
<ul>
<li><strong>初始化</strong>：启动构建，读取与合并配置参数，加载Plugin，实例化Compiler</li>
<li><strong>编译</strong>：从entry出发，针对每个module串行调用对应的loader去翻译文件内容，再递归处module依赖的module，形成构建图。</li>
<li><strong>输出</strong>：将编译后的module组合成chunk，最终将chunk转换成文件，输出到本地硬盘中。</li>
</ul>
<p>这其中编译阶段是最复杂的，另外还需考虑一个场景：watch mode（当文件变化时，重新进行编译），因此将编译阶段（即下文中的<code>compilation</code>）单独解耦出来。</p>
<p>在Webpack源码中，<code>compiler</code>代表上述说的三个阶段，在它上面挂载着各种生命周期函数，而<code>compilation</code>专门负责编译相关的工作。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/6751335793864999b09abea4feb05b77_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0_result.png" alt="6751335793864999b09abea4feb05b77_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0_result"></p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="搭建结构，读取配置参数，挂载配置文件中的插件"><a href="#搭建结构，读取配置参数，挂载配置文件中的插件" class="headerlink" title="搭建结构，读取配置参数，挂载配置文件中的插件"></a>搭建结构，读取配置参数，挂载配置文件中的插件</h2><p>webpack本质是一个函数，传入配置信息，并初始化Compiler实例，挂载plugin。随后调用compiler实例上的run方法进入编译阶段，修改webpack引用模块。</p>
<p><strong>.&#x2F;webpack.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebpackRunPlugin</span> &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">run</span>.<span class="title function_">tap</span>(<span class="string">&#x27;WebpackRunPlugin&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始编译&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebpackDonePlugin</span> &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">done</span>.<span class="title function_">tap</span>(<span class="string">&#x27;WebpackDonePlugin&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束编译&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">	<span class="comment">// 其他省略</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">WebpackRunPlugin</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">WebpackDonePlugin</span>()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>.&#x2F;debugger.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; webpack &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.js&#x27;</span>)</span><br><span class="line"><span class="comment">// const &#123; webpack &#125; = require(&#x27;webpack&#x27;)</span></span><br><span class="line"><span class="keyword">const</span> webpackOptions = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = <span class="title function_">webpack</span>(webpackOptions)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始编译</span></span><br><span class="line">compiler.<span class="title function_">run</span>(<span class="function">(<span class="params">err, stats</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">        stats.<span class="title function_">toJson</span>(&#123;</span><br><span class="line">            <span class="attr">assets</span>: <span class="literal">true</span>, <span class="comment">// 打印本次编译产出的资源</span></span><br><span class="line">            <span class="attr">chunks</span>: <span class="literal">true</span>, <span class="comment">// 打印本次编译产出的代码块</span></span><br><span class="line">            <span class="attr">modules</span>: <span class="literal">true</span> <span class="comment">// 打印本次编译产出的模块</span></span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>.&#x2F;webpack.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SyncHook</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;tapable&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compiler</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">webpackOptions</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span> = webpackOptions</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span> = &#123;</span><br><span class="line">      <span class="attr">run</span>: <span class="keyword">new</span> <span class="title class_">SyncHook</span>(), <span class="comment">// 会在编译刚开始的时候触发此run钩子</span></span><br><span class="line">      <span class="attr">done</span>: <span class="keyword">new</span> <span class="title class_">SyncHook</span>() <span class="comment">// 会在编译结束的时候触发此done钩子</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params">callback</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">webpack</span>(<span class="params">webpackOptions</span>) &#123;</span><br><span class="line">  <span class="comment">// 实例化Compiler</span></span><br><span class="line">  <span class="keyword">const</span> compiler = <span class="keyword">new</span> <span class="title class_">Compiler</span>(webpackOptions)</span><br><span class="line">  <span class="comment">// 挂载plugins</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> webpackOptions.<span class="property">plugins</span>)</span><br><span class="line">    plugin.<span class="title function_">apply</span>(compiler)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> compiler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行run方法开始执行编译"><a href="#执行run方法开始执行编译" class="headerlink" title="执行run方法开始执行编译"></a>执行run方法开始执行编译</h2><p>在正式编译之前需要调用compiler中的钩子函数（run和done），run用来通知插件要启动编译，done则通知插件编译完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compiler</span> &#123;</span><br><span class="line">  <span class="comment">//省略其他</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">compile</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">// Webpack只有一个compiler，但每次编译都会生成新的compilation</span></span><br><span class="line">    <span class="comment">// 这样做的目的是考虑到watch模式，它会在compiler启动的时候开始编译，然后监听依赖文件的变化</span></span><br><span class="line">    <span class="comment">// 文件每变化一次就生成新的compilation，表示最后编译的结果</span></span><br><span class="line">    <span class="keyword">const</span> compilation = <span class="keyword">new</span> <span class="title class_">Compilation</span>(<span class="variable language_">this</span>.<span class="property">options</span>)</span><br><span class="line">    compilation.<span class="title function_">build</span>(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">run</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">run</span>.<span class="title function_">call</span>() <span class="comment">// 触发run钩子函数，通知相关插件开始编译</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onCompiled</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">done</span>.<span class="title function_">call</span>() <span class="comment">// 当编译成功后触发done钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">compiled</span>(onCompiled) <span class="comment">// 开始编译，编译成功后调用onCompiled</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上文说到要将每次的编译操作解耦出来，这里单独定义Compilation类，完成有关编译相关的操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compilation</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">webpackOptions</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span> = webpackOptions</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">modules</span> = [] <span class="comment">// 本次编译产出的所有模块</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">chunks</span> = [] <span class="comment">// 本次编译产出的所有代码块（由入口模块和依赖的模块打包在一起）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">assets</span> = &#123;&#125; <span class="comment">// 本次编译产出的资源文件</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fileDependences</span> = [] <span class="comment">// 本次编译依赖的文件模块，主要为后续监听文件内容变化服务</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">build</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里开始执行编译工作，编译成功后调用callback</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根据配置中的entry找到所有项目入口"><a href="#根据配置中的entry找到所有项目入口" class="headerlink" title="根据配置中的entry找到所有项目入口"></a>根据配置中的<code>entry</code>找到所有项目入口</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compilation</span> &#123;</span><br><span class="line">  <span class="comment">// 省略其他</span></span><br><span class="line">  <span class="title function_">build</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> entry = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">entry</span> === <span class="string">&#x27;string&#x27;</span>) </span><br><span class="line">      <span class="comment">// 标准化entry &#x27;./src/index.js&#x27; =&gt; &#123; main: &#x27;./src/index.js&#x27; &#125;</span></span><br><span class="line">      entry.<span class="property">main</span> = <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">entry</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      entry = <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">entry</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> entryName <span class="keyword">in</span> entry) &#123;</span><br><span class="line">      <span class="comment">// 获取entry的绝对路径</span></span><br><span class="line">      <span class="keyword">const</span> entryFilePath = path.<span class="property">posix</span>.<span class="title function_">join</span>(baseDir, entry[entryName])</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">fileDependences</span>.<span class="title function_">push</span>(entryFilePath)</span><br><span class="line">      <span class="comment">// 构建入口模块</span></span><br><span class="line">      <span class="keyword">const</span> entryModule = <span class="variable language_">this</span>.<span class="title function_">buildModule</span>(entryName, entryFilePath)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">callback</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从入口文件出发，调用配置的loader"><a href="#从入口文件出发，调用配置的loader" class="headerlink" title="从入口文件出发，调用配置的loader"></a>从入口文件出发，调用配置的<code>loader</code></h2><p>loader主要用来翻译模块内容，其本质就是一个函数，串行接收上一个loader返回的内容再将其进行处理交给下一个loader进一步处理，最终得到想要的内容。</p>
<p>这里写两个自定义的loader配置到<strong>webpack.config.js</strong>中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">loader1</span> = (<span class="params">source</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> source + <span class="string">&#x27;//给你的代码加点注释：loader1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">loader2</span> = (<span class="params">source</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> source + <span class="string">&#x27;//给你的代码加点注释：loader2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 其他省略</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [loader1, loader2]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步骤从入口文件出发，找到与之匹配的loader对源代码进行翻译和替换。</p>
<p>主要有三个要点：</p>
<ul>
<li>把入口文件添加到<code>dependences</code>数组中，记录此次编译依赖的模块</li>
<li>得到入口模块的<code>module</code>对象，里面记录着路径、源代码、依赖模块等</li>
<li>将生成的入口模块添加到<code>modules</code>数组中</li>
</ul>
<blockquote>
<p>把入口文件添加到<code>dependences</code>数组中，记录此次编译依赖的模块</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toUnixPath</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> path.<span class="title function_">replace</span>(<span class="regexp">/\\/g</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> baseDir = <span class="title function_">toUnixPath</span>(process.<span class="title function_">cwd</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compilation</span> &#123;</span><br><span class="line">  <span class="comment">// 省略其他</span></span><br><span class="line">  <span class="title function_">build</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> entryName <span class="keyword">in</span> entry) &#123;</span><br><span class="line">      <span class="comment">// 获取entry的绝对路径</span></span><br><span class="line">      <span class="keyword">const</span> entryFilePath = path.<span class="property">posix</span>.<span class="title function_">join</span>(baseDir, entry[entryName])</span><br><span class="line">      <span class="comment">// 记录</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">fileDependences</span>.<span class="title function_">push</span>(entryFilePath)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>得到入口模块的<code>module</code>对象，里面记录着路径、源代码、依赖模块等</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compilation</span> &#123;</span><br><span class="line">  <span class="comment">// 省略其他</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">build</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">buildModule</span>(<span class="params">name, modulePath</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> sourceCode = fs.<span class="title function_">readFileSync</span>(modulePath)</span><br><span class="line">      <span class="comment">// 以模块路径相对于当前文件夹作的路径作为模块id</span></span><br><span class="line">      <span class="keyword">let</span> moduleId = <span class="string">&#x27;./&#x27;</span> + path.<span class="property">posix</span>.<span class="title function_">relative</span>(baseDir, modulePath)</span><br><span class="line">      <span class="comment">// 创建模块对象</span></span><br><span class="line">      <span class="keyword">const</span> moudle = &#123;</span><br><span class="line">        <span class="attr">id</span>: moduleId,</span><br><span class="line">        <span class="attr">names</span>: [name], <span class="comment">// 表示当前模块从属于哪些chunk</span></span><br><span class="line">        <span class="attr">_source</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">dependences</span>: [] <span class="comment">// 该模块依赖的模块</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取模块依赖的loader</span></span><br><span class="line">      <span class="keyword">const</span> loaders = []</span><br><span class="line">      <span class="keyword">const</span> &#123; rules &#125; = <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">module</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> rule <span class="keyword">of</span> rules) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rule.<span class="property">test</span>.<span class="title function_">test</span>(modulePath))</span><br><span class="line">          loaders.<span class="title function_">push</span>(...rule.<span class="property">use</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用loader对源代码进行翻译转换，loader调用顺序为从右向左</span></span><br><span class="line">      sourceCode = loaders.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">code, loader</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">loader</span>(code)</span><br><span class="line">      &#125;, sourceCode)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> entryName <span class="keyword">in</span> entry) &#123;</span><br><span class="line">      <span class="comment">// 获取entry的绝对路径</span></span><br><span class="line">      <span class="keyword">const</span> entryFilePath = path.<span class="property">posix</span>.<span class="title function_">join</span>(baseDir, entry[entryName])</span><br><span class="line">      <span class="comment">// 记录</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">fileDependences</span>.<span class="title function_">push</span>(entryFilePath)</span><br><span class="line">      <span class="comment">// 构建入口模块</span></span><br><span class="line">      <span class="keyword">const</span> entryModule = <span class="variable language_">this</span>.<span class="title function_">buildModule</span>(entryName, entryFilePath)</span><br><span class="line">      <span class="comment">// 将入口模块保存至modules数组中</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">modules</span>.<span class="title function_">push</span>(entryModule)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找出当前模块依赖的模块，再对依赖模块进行处理"><a href="#找出当前模块依赖的模块，再对依赖模块进行处理" class="headerlink" title="找出当前模块依赖的模块，再对依赖模块进行处理"></a>找出当前模块依赖的模块，再对依赖模块进行处理</h2><p>当前这个步骤是整个流程中最为复杂的部分，我们可以将其拆分为以下步骤方便理解：</p>
<ul>
<li>先将源码转化为<strong>AST</strong></li>
<li>在<code>AST</code>中查找<code>require</code>语句</li>
<li><code>require</code>语句的参数就是依赖模块的路径，与之对应的绝对路径添加至<code>this.fileDependences</code>中</li>
<li>生成依赖模块的<code>模块id</code></li>
<li>修改<code>require</code>语句的参数，将其改为<code>模块id</code></li>
<li>将依赖模块的信息添加到<code>module.dependences</code>数组中</li>
<li>生成新代码，并将其保存至<code>module._source</code>中</li>
<li>对依赖模块遍历，递归处理依赖的模块（<code>module.dependences</code>）</li>
<li>将上一步函数的返回值得到依赖模块的<code>module对象</code>添加到<code>this.modules</code>数组中</li>
<li>等所有依赖模块处理完成后，返回入口模块的<code>module对象</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;@babel/parser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> types = <span class="built_in">require</span>(<span class="string">&#x27;@babel/types&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> generator = <span class="built_in">require</span>(<span class="string">&#x27;@babel/generator&#x27;</span>).<span class="property">default</span></span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&#x27;@babel/traverse&#x27;</span>).<span class="property">default</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tryExtensions</span>(<span class="params">filePath, extension</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (fs.<span class="title function_">existsSync</span>(filePath)) <span class="keyword">return</span> filePath</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; extensions.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> path = filePath + extensions[i]</span><br><span class="line">    <span class="keyword">if</span> (fs.<span class="title function_">existsSync</span>(path)) <span class="keyword">return</span> path</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`无法找到<span class="subst">$&#123;filePath&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compilation</span> &#123;</span><br><span class="line">  <span class="comment">// 省略其他</span></span><br><span class="line">  <span class="title function_">buildModule</span>(<span class="params">name, modulePath</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 将源码转为AST</span></span><br><span class="line">    <span class="keyword">const</span> ast = parser.<span class="title function_">parse</span>(sourceCode, &#123; <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span> &#125;)</span><br><span class="line">    <span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">      <span class="title class_">CallExpression</span>: <span class="function">(<span class="params">nodePath</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; node &#125; = nodePath</span><br><span class="line">        <span class="comment">// 在AST中查找require语句</span></span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">callee</span>.<span class="property">name</span> === <span class="string">&#x27;require&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">// 获取依赖模块名</span></span><br><span class="line">          <span class="keyword">const</span> depModuleName = node.<span class="property">arguments</span>[<span class="number">0</span>].<span class="property">value</span></span><br><span class="line">          <span class="comment">// 获取入口模块所处文件目录</span></span><br><span class="line">          <span class="keyword">const</span> dirname = path.<span class="property">posix</span>.<span class="title function_">dirname</span>(modulePath)</span><br><span class="line">          <span class="comment">// 得到依赖模块的绝对路径</span></span><br><span class="line">          <span class="keyword">let</span> depModulePath = path.<span class="property">posix</span>.<span class="title function_">join</span>(dirname, depModuleName)</span><br><span class="line">          <span class="comment">// 由于依赖模块名可能会省略文件后缀，因此需依次在文件系统中查找是否存在对应文件后缀的文件</span></span><br><span class="line">          <span class="keyword">const</span> extensions = <span class="variable language_">this</span>.<span class="property">options</span>?.<span class="property">resolve</span>?.<span class="property">extension</span> || [<span class="string">&#x27;.js&#x27;</span>]</span><br><span class="line">          depModulePath = <span class="title function_">tryExtensions</span>(depModulePath, extensions)</span><br><span class="line">          <span class="comment">// 统一将baseDir的相对路径作为模块id</span></span><br><span class="line">          <span class="keyword">const</span> depModuleId = <span class="string">&#x27;./&#x27;</span> + path.<span class="property">posix</span>.<span class="title function_">relative</span>(baseDir, depModulePath)</span><br><span class="line">          <span class="comment">// 把require语句参数改为模块id</span></span><br><span class="line">          node.<span class="property">arguments</span> = [types.<span class="title function_">stringLiteral</span>(depModuleId)]</span><br><span class="line">          <span class="comment">// 将依赖模块信息保存至依赖数组中</span></span><br><span class="line">          <span class="variable language_">module</span>.<span class="property">dependences</span>.<span class="title function_">push</span>(&#123; depModulePath, depModuleId &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 将修改后的AST转为源码并保存起来</span></span><br><span class="line">    <span class="keyword">const</span> &#123; code &#125; = <span class="title function_">generator</span>(ast)</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">_source</span> = code</span><br><span class="line">    <span class="comment">// 依次遍历依赖模块，对其递归处理</span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">dependences</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123; depModuleId, depModulePath &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> existModule = <span class="variable language_">this</span>.<span class="property">modules</span>.<span class="title function_">find</span>(<span class="function"><span class="params">module</span> =&gt;</span> <span class="variable language_">module</span>.<span class="property">id</span> === depModuleId)</span><br><span class="line">      <span class="keyword">if</span> (existModule) <span class="comment">// modules数组中已经存在当前模块，只需将entryName加入names数组中</span></span><br><span class="line">        existModule.<span class="property">names</span>.<span class="title function_">push</span>(name)</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="keyword">const</span> depModule = <span class="variable language_">this</span>.<span class="title function_">buildModule</span>(name, depModlePath)</span><br><span class="line">        depModule.<span class="property">names</span>.<span class="title function_">push</span>(name)</span><br><span class="line">        <span class="comment">// 将依赖模块添加至modules数组中</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">modules</span>.<span class="title function_">push</span>(depModule)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 处理完成入口模块，将其返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">module</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>至此，对于模块编译阶段的核心部分已揭露完成，可以运行查看有关编译结果</p>
</blockquote>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/image-20230405201355183.png" alt="image-20230405201355183"></p>
<p>以上为<code>entryModule</code>的输出，由于配置文件中只有一个入口，因此只生成一个<code>entryModule</code></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/image-20230405202127931.png" alt="image-20230405202127931"></p>
<p>以上为<code>this.modules</code>的输出，可以看出能够收集入口模块的依赖模块。</p>
<h2 id="将入口模块及其依赖的模块组合成代码块chunk"><a href="#将入口模块及其依赖的模块组合成代码块chunk" class="headerlink" title="将入口模块及其依赖的模块组合成代码块chunk"></a>将入口模块及其依赖的模块组合成代码块<code>chunk</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略其他</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compilation</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="title function_">build</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> entryName <span class="keyword">in</span> entry) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">const</span> entryModule = <span class="variable language_">this</span>.<span class="title function_">buildModule</span>(entryName, entryFilePath)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">modules</span>.<span class="title function_">push</span>(entryModule)</span><br><span class="line">      <span class="comment">// 当前入口模块已处理完，生成一个chunk</span></span><br><span class="line">      <span class="keyword">const</span> chunk = &#123;</span><br><span class="line">        entryModule,</span><br><span class="line">        <span class="attr">name</span>: entryName,</span><br><span class="line">        <span class="comment">// 找出当前entry所有依赖的module</span></span><br><span class="line">        <span class="attr">modules</span>: <span class="variable language_">this</span>.<span class="property">modules</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">module</span> =&gt;</span> <span class="variable language_">module</span>.<span class="property">names</span>.<span class="title function_">includes</span>(entryName))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">chunks</span>.<span class="title function_">push</span>(chunk)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this.chunks</code>的输出内容</p>
<img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/image-20230405205011305.png" alt="image-20230405205011305" style="zoom:80%;" />

<h2 id="把各个代码块chunk转换成待输出文件的内容（this-assets）"><a href="#把各个代码块chunk转换成待输出文件的内容（this-assets）" class="headerlink" title="把各个代码块chunk转换成待输出文件的内容（this.assets）"></a>把各个代码块<code>chunk</code>转换成待输出文件的内容（<code>this.assets</code>）</h2><p>这一步需要结合配置项中的<code>output.filename</code>去生成输出文件的文件名，同时还需生成运行时代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSource</span>(<span class="params">chunk</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">  (() =&gt; &#123;</span></span><br><span class="line"><span class="string">  var modules = &#123;</span></span><br><span class="line"><span class="string">  	<span class="subst">$&#123;chunk.modules.map(<span class="variable language_">module</span> =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  		&quot;$(module.id)&quot;: (module) =&gt; &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  			<span class="subst">$&#123;<span class="variable language_">module</span>._source&#125;</span></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  		&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  	`</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">  var cache = &#123;&#125;;</span></span><br><span class="line"><span class="string">  function require(moduleId) &#123;</span></span><br><span class="line"><span class="string">  	var cachedModule = cache[moduleId];</span></span><br><span class="line"><span class="string">  	if (cachedModule) return cachedModule.exports;</span></span><br><span class="line"><span class="string">  	var module = (cache[moduleId] = &#123; exports: &#123;&#125; &#125;);</span></span><br><span class="line"><span class="string">  	modules[moduleId](module, module.exports, require);</span></span><br><span class="line"><span class="string">  	return module.exports;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;chunk.entryModule._source&#125;</span></span></span><br><span class="line"><span class="string">  &#125;)();</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compilation</span> &#123;</span><br><span class="line">  <span class="comment">// 省略其他</span></span><br><span class="line">  <span class="title function_">build</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">chunks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> filename = <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">output</span>.<span class="property">filename</span>.<span class="title function_">replace</span>(<span class="string">&#x27;[name]&#x27;</span>, chunk.<span class="property">name</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">assets</span>[filename] = <span class="title function_">getSource</span>(chunk)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">callback</span>(</span><br><span class="line">    	<span class="literal">null</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">chunks</span>: <span class="variable language_">this</span>.<span class="property">chunks</span>,</span><br><span class="line">        <span class="attr">modules</span>: <span class="variable language_">this</span>.<span class="property">modules</span>,</span><br><span class="line">        <span class="attr">assets</span>: <span class="variable language_">this</span>.<span class="property">assets</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">fileDependences</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this.assets</code>的输出结果为对象，其中属性为文件名，值为对应的文件内容</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/image-20230405205251011.png" alt="image-20230405205251011"></p>
<h2 id="确定好输出内容后，将文件内容写入文件系统"><a href="#确定好输出内容后，将文件内容写入文件系统" class="headerlink" title="确定好输出内容后，将文件内容写入文件系统"></a>确定好输出内容后，将文件内容写入文件系统</h2><p>这一步只需根据配置项的<code>output.path</code>，将<code>this.assets</code>中的内容写入到相应文件中，最终就可以得到打包后的文件内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compiler</span> &#123;</span><br><span class="line">  <span class="comment">// 省略其他</span></span><br><span class="line">  <span class="title function_">run</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">run</span>.<span class="title function_">call</span>()</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onCompiled</span> = (<span class="params">err, stats, fileDependences</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 将输出内容写入到文件系统中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> filename <span class="keyword">in</span> stats.<span class="property">assets</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> filePath = path.<span class="title function_">join</span>(<span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">output</span>.<span class="property">path</span>, filename)</span><br><span class="line">        fs.<span class="title function_">writeFileSync</span>(filePath, stats.<span class="property">assets</span>[filename], <span class="string">&#x27;uft-8&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">callback</span>(err, &#123;</span><br><span class="line">        <span class="attr">toJson</span>: <span class="function">() =&gt;</span> stats</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">done</span>.<span class="title function_">call</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">compile</span>(onCompiled)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现watch模式"><a href="#实现watch模式" class="headerlink" title="实现watch模式"></a>实现watch模式</h1><p>在结构设计时提过，将编译过程单独解耦出来的原因之一就是要监听依赖模块文件的变化，当文件变化时重新执行编译。</p>
<p>这里的思路就是对<code>this.fileDependences</code>数组中的文件进行监听，当文件发生变化时，重新执行<code>compile</code>函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compiler</span> &#123;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onCompiled</span> = (<span class="params">err, stats, fileDependences</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      fileDependences.<span class="title function_">forEach</span>(<span class="function"><span class="params">fileDependence</span> =&gt;</span> &#123;</span><br><span class="line">        fs.<span class="title function_">watch</span>(fileDependence, <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">compile</span>(onCompiled))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这也就能明白单独解耦出<code>Compilation</code>的作用了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文从Webpack的基本使用及构建流程出发，实现了一个简易版本的Webpack，尽管它只能对js文件打包，还缺少许多功能，但对于后续理解Webpack源码还是有一定的启发性，麻雀虽小，五脏俱全。</p>
]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>wepback</tag>
        <tag>手写webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 3.2 响应式原理——手写简易版本</title>
    <url>/3726c66/</url>
    <content><![CDATA[<blockquote>
<p>在进行正式阅读Vue3.2 响应式源码前，先来了解响应式的核心原理，并自己实现一个基础的响应式数据系统</p>
</blockquote>
<span id="more"></span>

<h1 id="响应式数据前瞻"><a href="#响应式数据前瞻" class="headerlink" title="响应式数据前瞻"></a>响应式数据前瞻</h1><h2 id="不智能的数据"><a href="#不智能的数据" class="headerlink" title="不智能的数据"></a>不智能的数据</h2><p>我们正常编写js代码的时候，变量值的改变不会触发相关视图依赖更新，如下面代码所示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reactive = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = reactive.<span class="property">a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">effect</span>()</span><br><span class="line">reactive.<span class="property">a</span> = <span class="string">&#x27;edited&#x27;</span> <span class="comment">// 变量修改，不会触发effect函数执行，需要手动调用</span></span><br><span class="line"><span class="title function_">effect</span>() <span class="comment">// 手动调用，更新视图</span></span><br></pre></td></tr></table></figure>
<h1 id="Vue中智能的数据"><a href="#Vue中智能的数据" class="headerlink" title="Vue中智能的数据"></a>Vue中智能的数据</h1><p>在Vue编写的数据，当数据变化时，相关的视图也会实时更新，官方称之为响应式数据，实现响应式数据的核心就是<strong>数据劫持</strong>和<strong>发布订阅</strong>。一句话概括就是通过劫持数据的获取（getter）操作来收集依赖，劫持数据的设置（setter）操作来触发依赖，其中收集依赖和触发依赖就是发布订阅模式的核心思想。</p>
<p>在Vue2中，数据劫持是通过<code>Object.defineProperty</code>来完成对象属性的获取（getter）和设置（setter）操作；Vue3则是通过<code>Proxy + Reflect</code>来完成对象属性相关劫持操作。下面可以使用<code>Proxy</code>来简单实现一个响应式数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前被激活的依赖</span></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  activeEffect = fn</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">fn</span>()</span><br><span class="line">  activeEffect = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于保存依赖的对应关系 target -&gt; key -&gt; effect</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="comment">// 依赖收集</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 当前没有被激活的依赖，直接退出</span></span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 先获取 target 映射的依赖收集器</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">  <span class="comment">// 再获取 key 映射的依赖，里面用于存放依赖</span></span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!deps) depsMap.<span class="title function_">set</span>(key, (deps = <span class="keyword">new</span> <span class="title class_">Set</span>()))</span><br><span class="line">  <span class="keyword">if</span> (!deps.<span class="title function_">has</span>(activeEffect)) deps.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发依赖</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key, newValue, oldValue</span>) &#123;</span><br><span class="line">  <span class="comment">// 值没变化直接退出</span></span><br><span class="line">  <span class="keyword">if</span> (newValue === oldValue) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!deps) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> effects = [...deps]</span><br><span class="line">  effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> <span class="title function_">effect</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把普通对象变成响应式对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">originData</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> reactiveData = <span class="keyword">new</span> <span class="title class_">Proxy</span>(originData, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="comment">// 收集当前激活的依赖</span></span><br><span class="line">      <span class="title function_">track</span>(target, key)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = target[key]</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">      <span class="comment">// 触发对应的依赖</span></span><br><span class="line">      <span class="title function_">trigger</span>(target, key, value, oldValue)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> reactiveData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个响应式对象</span></span><br><span class="line"><span class="keyword">const</span> originData = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;f1ower1ang&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reactiveData = <span class="title function_">reactive</span>(originData)</span><br><span class="line"><span class="comment">// f1ower1ang-18</span></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = <span class="string">`<span class="subst">$&#123;reactiveData.name&#125;</span>-<span class="subst">$&#123;reactiveData.age&#125;</span>`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// edited-f1ower1ang-18</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  reactiveData.<span class="property">name</span> = <span class="string">&#x27;edited-f1ower1ang&#x27;</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>可以把上面的内容复制到浏览器控制台中运行一下，可以发现body元素起始内容为<code>f1ower1ang-18</code>，过了一秒后会自动更新为<code>edited-f1ower1ang-18</code>。这就是响应式数据的魅力所在，不需要我们修改完数据后手动操作去触发视图更新。</p>
<p>上述代码中，<code>WeakMap</code>和<code>Proxy</code>就是发布订阅模式的核心，其中<code>WeakMap</code>负责收集事件的订阅，<code>Proxy</code>中的getter和setter负责订阅事件和触发事件执行，这里的事件就是指传入effect中的函数参数，在Vue中则是和挂载组件以及组件更新相关的函数。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文从不具备响应式的数据作为切入点，到手写一个简单的响应式数据系统，为接下来的源码阅读打基础，下节则直接阅读源码，彻底掌握Vue3的响应式数据。</p>
]]></content>
      <categories>
        <category>Vue系列源码</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
        <tag>Vue源码</tag>
      </tags>
  </entry>
  <entry>
    <title>简易版Vue Router实现</title>
    <url>/a3bdff3d/</url>
    <content><![CDATA[<blockquote>
<p>前端路由管理在单页面应用中发挥着重要作用，单页面应用本质就是一个<code>index.html</code>，其路由的切换原理就是根据配置的路由信息替换有关页面组件，不同于传统的路由切换，单页面应用的路由切换不会刷新页面，因为不经过服务端。本文主要记录 Vue Router3 核心原理，并手写核心功能。</p>
</blockquote>
<span id="more"></span>

<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>在理解VueRouter原理之前，需掌握有关前端路由的知识，前端路由有两种模式：hash和history。在这两种路由模式下修改路由信息不会刷新页面。</p>
<h2 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h2><p>hash就是URL上的锚点，比如<code>https://www.example.com/#home</code>，#后面就是URL的hash，比如这里的#home。</p>
<p>hash值可以通过<code>window.location.hash</code>获取，它是以#开头的。</p>
<p>监听<code>hashchange</code>事件可以监听hash值的变化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 监听 hash 变化，获取最新的 hash 值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h2><p>HTML5为浏览器的history对象新增了两个方法：history.pushState() 和 history.replaceState()，用来添加和修改浏览历史记录。这两个方法都可以修改浏览器的URL且<strong>不会刷新页面</strong>。history模式下的路径是正常，路由间跳转是正常的，但当用户刷新时，会发生404，需在服务端进行处理。</p>
<p>监听<code>popstate</code>事件可以监听到用户点击浏览器后退和前进按钮时，路由信息的变化；调用 pushState 或 replaceState 方法不会触发该事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 监听 popstate，获取最新的 pathname</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p><strong>.&#x2F;main.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/about.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册VueRouter</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;hash&#x27;</span>, <span class="comment">// 路由模式</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: &#123; <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: &#123; <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">About</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Router实例作为配置项传给Vue根实例</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;router, <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>可以看出，VueRouter是一个类，只需配置路由模式（默认为hash）、路由表（routes）就可获得router实例，将其传入根组件配置项中，并注册VueRouter插件，这样可以在每个组件中获取router实例；另外还支持路由嵌套（通过配置route的children），下文将对其中实现详细展开。</p>
<h1 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h1><p>我们配置使用VueRouter可以发现，<code>vue-router</code> 默认导出一个class，同时它还需作为插件安装到Vue实例上，因此VueRouter类上需实现install方法在组件实例上注册Router实例，让每个组件都能获取Router实例信息。</p>
<p>整体的目录结构设计如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">└── src # 源码目录</span><br><span class="line">     ├── components # vue-router组件</span><br><span class="line">     │   ├── link.js # router-link</span><br><span class="line">     │   └── view.js # router-view</span><br><span class="line">     ├── create-matcher.js # 路由匹配器，动态添加路由信息</span><br><span class="line">     ├── create-route-map.js # 创建路由映射，扁平化路由表</span><br><span class="line">     ├── history # 路由模式</span><br><span class="line">     │   ├── base.js # 路由模式基类</span><br><span class="line">     │   ├── hash.js</span><br><span class="line">     │   └── history.js</span><br><span class="line">     ├── index.js # vue-router入口</span><br><span class="line">     └── install.js # vue-router插件注册</span><br></pre></td></tr></table></figure>



<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="vue-router的注册"><a href="#vue-router的注册" class="headerlink" title="vue-router的注册"></a>vue-router的注册</h2><p>在Vue2中的组件上，我们可以通过 <code>this.$router</code> 获取到Router实例，这个操作在vue-router注册时完成的，当执行Vue.use方法注册插件时，会调用插件上的install方法，并将Vue构造函数作为参数传入，Vue构造函数中存在许多静态方法，其中mixin方法可以给每个组件注入配置，从而在组件实例上添加相关信息，具体实现如下：</p>
<p><strong>.&#x2F;src&#x2F;install.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> link <span class="keyword">from</span> <span class="string">&#x27;./components/link.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> view <span class="keyword">from</span> <span class="string">&#x27;./components/view.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="title class_">Vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">install</span>(<span class="params">_Vue</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果是多次注册，则直接return</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Vue</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="title class_">Vue</span> = _Vue <span class="comment">// 共享给其他模块使用</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123; <span class="comment">// 创建组件实例前，会合并mixin中的配置</span></span><br><span class="line">    <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 这里面的this指向当前的组件</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">router</span>) &#123; <span class="comment">// 根实例 new Vue</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_routerRoot</span> = <span class="variable language_">this</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_router</span> = <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">router</span> <span class="comment">// 把router实例保存起来</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从父组件中获取根实例，后续执行 this._routerRoot._router获取router实例</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_routerRoot</span> = <span class="variable language_">this</span>.<span class="property">$parent</span>?.<span class="property">_routerRoot</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 组件可以通过 this.$router 获取router实例</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;$router&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_routerRoot</span>?.<span class="property">_router</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注册全局组件 router-link router-view</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;router-link&#x27;</span>, link)</span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;router-view&#x27;</span>, view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们实现了 install 方法，主要是用到 mixin 给每个组件添加 router 实例，以及使用 component 注册全局组件：router-link和router-view，这两个组件后续会详细介绍。</p>
<p>执行 <code>Vue.use(VueRouter)</code> 时会调用 install 方法，因此需要将 install 注册为 VueRouter 的静态方法。</p>
<p><strong>.&#x2F;src&#x2F;index.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; install &#125; <span class="keyword">from</span> <span class="string">&#x27;./install.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VueRouter</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> install</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">VueRouter</span>.<span class="property">install</span> = install</span><br></pre></td></tr></table></figure>

<h2 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h2><p>VueRouter类中需要完成的工作如下：</p>
<ul>
<li><p>实例化VueRouter，即执行constructor方法。主要工作如下：</p>
<ul>
<li>根据路由配置信息创建匹配器（路径和路由信息的映射），由于routes是一个数组，且每个路由还可能包含嵌套路由，因此需要提取其中的路径信息，形成一种映射关系，后续可直接根据路径信息获取到路由信息。</li>
<li>根据路由模式创建对应的路由管理，前面提到hash和history模式监听路径信息变化相关事件，需分别对其处理；但核心功能还是根据当前的路径获取到匹配器中的相关记录，并生成路由信息（route），后续router-view组件将根据route渲染其中的组件。</li>
</ul>
</li>
<li><p>初始化VueRouter，即执行init方法。主要工作如下：</p>
<ul>
<li>当在根实例（new Vue）创建前，设置好当前的route，并监听路径的变化。</li>
</ul>
</li>
</ul>
<h3 id="VueRouter-实例化"><a href="#VueRouter-实例化" class="headerlink" title="VueRouter 实例化"></a>VueRouter 实例化</h3><p><strong>.&#x2F;src&#x2F;index.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VueRouter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="comment">// 用户配置的路由记录</span></span><br><span class="line">    <span class="keyword">let</span> routes = options.<span class="property">routes</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建匹配器，扁平化routes</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">matcher</span> = <span class="title function_">createMatcher</span>(routes)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据路由模式创建不同路由管理器，其主要功能是监听路径变化，根据当前路径信息创建route用于router-view页面组件渲染</span></span><br><span class="line">    <span class="keyword">const</span> mode = options.<span class="property">mode</span> || <span class="string">&#x27;hash&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (mode === <span class="string">&#x27;hash&#x27;</span>) <span class="variable language_">this</span>.<span class="property">history</span> = <span class="keyword">new</span> <span class="title class_">HashHistory</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode === <span class="string">&#x27;history&#x27;</span>) <span class="variable language_">this</span>.<span class="property">history</span> = <span class="keyword">new</span> <span class="title class_">BrowserHistory</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建路由匹配器"><a href="#创建路由匹配器" class="headerlink" title="创建路由匹配器"></a>创建路由匹配器</h4><p>匹配器的主要功能：</p>
<ul>
<li>创建路径和路由的映射记录。</li>
<li>动态添加路由记录，即动态添加映射记录</li>
</ul>
<p><strong>.&#x2F;src&#x2F;create-matcher.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouteMap &#125; <span class="keyword">from</span> <span class="string">&#x27;./create-route-map.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createMatcher</span>(<span class="params">routes</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathMap &#125; = <span class="title function_">createRouteMap</span>(routes)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 动态添加路由记录</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">addRoutes</span>(<span class="params">routes</span>) &#123;</span><br><span class="line">    <span class="title function_">createRouteMap</span>(routes, pathMap)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">addRoute</span>(<span class="params">route</span>) &#123;</span><br><span class="line">    <span class="title function_">createRouteMap</span>([route], pathMap)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">match</span>(<span class="params">location</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> pathMap[location]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123; addRoutes, addRoute, match &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中核心就是createRouteMap，它会将route配置的path作为key（考虑到存在嵌套路由，因此还需标准化path），value则是包含对应的页面组件以及父级路由记录等关键信息。具体实现如下：</p>
<p><strong>.&#x2F;src&#x2F;create-route-map.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRouteMap</span>(<span class="params">routes, pathMap = &#123;&#125;</span>) &#123;</span><br><span class="line">  routes.<span class="title function_">forEach</span>(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">addRouteRecord</span>(route, pathMap)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; pathMap &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里需递归处理嵌套的route，为了后续页面组件展示，将其父级记录保存</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addRouteRecord</span>(<span class="params">route, pathMap, parentRecord</span>) &#123;</span><br><span class="line">  <span class="comment">// 简单格式化当前路径（嵌套路由需加上父级的路径）</span></span><br><span class="line">  <span class="keyword">let</span> path = parentRecord </span><br><span class="line">    ? <span class="string">`<span class="subst">$&#123;parentRecord.path === <span class="string">&#x27;/&#x27;</span> ? <span class="string">&#x27;/&#x27;</span> : <span class="string">`<span class="subst">$&#123;parentRecord.path&#125;</span>/`</span>&#125;</span><span class="subst">$&#123;route.path&#125;</span>`</span></span><br><span class="line">    : route.<span class="property">path</span></span><br><span class="line">  <span class="keyword">let</span> record = pathMap[path] || &#123;</span><br><span class="line">    path,</span><br><span class="line">    <span class="attr">component</span>: route.<span class="property">component</span>,</span><br><span class="line">    <span class="attr">props</span>: route.<span class="property">props</span>,</span><br><span class="line">    <span class="attr">meta</span>: route.<span class="property">meta</span>,</span><br><span class="line">    <span class="attr">parent</span>: parentRecord</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!pathMap[path]) pathMap[path] = record</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 递归处理嵌套的子路由</span></span><br><span class="line">  route.<span class="property">children</span>?.<span class="title function_">forEach</span>(<span class="function"><span class="params">childRoute</span> =&gt;</span> <span class="title function_">addRouteRecord</span>(childRoute, pathMap, record))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入的routes配置为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">HomeView</span>,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: &#123; <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: &#123; <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/AboutView.vue&#x27;</span>),</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: &#123; <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;about a&#x27;</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>经过扁平化处理后，pathMap结果如下：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304111517994.png" alt="image-20230411151755930"></p>
<p>执行<code>addRoute</code>和<code>addRoutes</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="property">matcher</span>.<span class="title function_">addRoute</span>(&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: &#123;</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="property">matcher</span>.<span class="title function_">addRoutes</span>([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: &#123;</span><br><span class="line">          <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;about c&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>可以发现pathMap上已经添加上相关记录</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304112257865.png" alt="image-20230411225718690"></p>
<h4 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h4><p>前端路由模式分为：hash和history，前面已经介绍过了，对于这两种模式相同的部分可以提取出基类（History），用来完成根据当前路径和路由匹配器生成路由信息。</p>
<p>这里需要获取对应路径的记录信息（pathMap），因此需要在Router实例中代理matcher的匹配方法，方便History基类直接调用。</p>
<p><strong>.&#x2F;src&#x2F;index.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VueRouter</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">match</span>(<span class="params">location</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">matcher</span>.<span class="title function_">match</span>(location)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基类History实现如下：</p>
<p><strong>.&#x2F;src&#x2F;history&#x2F;base.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; record 路径对应到pathMap的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@parem</span> &#123;<span class="type">string</span>&#125; location 路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Object</span>&#125; 返回当前路径对应的路由信息（路径、匹配的页面组件）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRoute</span>(<span class="params">record, location</span>) &#123;</span><br><span class="line">  <span class="comment">// 找出当前路由下所有的路由记录，后续 router-view 会根据嵌套层级渲染对应的组件</span></span><br><span class="line">  <span class="keyword">const</span> matched = []</span><br><span class="line">  <span class="comment">// 向上查找父级记录，并添加到数组头部</span></span><br><span class="line">  <span class="keyword">while</span> (record) &#123;</span><br><span class="line">    matched.<span class="title function_">unshift</span>(record)</span><br><span class="line">    record = record.<span class="property">parent</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...location,</span><br><span class="line">    matched</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">History</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">router</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">router</span> = router</span><br><span class="line">    <span class="comment">// 当前路由信息</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">current</span> = <span class="title function_">createRoute</span>(<span class="literal">null</span>, &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据当前路径，生成路由信息并更新 currentRoute</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; location 当前路径</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">function</span>&#125; listener 需执行的回调函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">transitionTo</span>(<span class="params">location, listener</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> record = <span class="variable language_">this</span>.<span class="property">router</span>.<span class="title function_">match</span>(location) <span class="comment">// 获取匹配的路由记录</span></span><br><span class="line">    <span class="keyword">const</span> route = <span class="title function_">createRoute</span>(record, &#123; <span class="attr">path</span>: location &#125;) <span class="comment">// 创建路由实例</span></span><br><span class="line">    <span class="comment">// 只有当前路径改变时才执行后续操作，由于默认是 根路径&#x27;/&#x27;，因此还需根据 matched 数组长度来特判</span></span><br><span class="line">    <span class="keyword">if</span> (location === <span class="variable language_">this</span>.<span class="property">current</span>.<span class="property">path</span> &amp;&amp; route.<span class="property">matched</span>.<span class="property">length</span> === <span class="variable language_">this</span>.<span class="property">current</span>.<span class="property">matched</span>.<span class="property">length</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">current</span> = route</span><br><span class="line">    listener &amp;&amp; <span class="title function_">listener</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于嵌套路由的页面组件渲染，还需要根据当前页面嵌套的层级，从而依次渲染出对应层级的页面组件。</p>
<p>我们在使用VueRouter时还可以通过<code>this.$router.push</code>方法手动跳转到相应页面，其主要跳转操作还是借助<code>transitonTo</code>方法，随后根据路由模式改变地址栏URL信息，因此本操作需分别在<code>HashHistory</code>和<code>BrowserHistory</code>类中实现。</p>
<p><strong>.&#x2F;src&#x2F;history&#x2F;hash.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">History</span> <span class="keyword">from</span> <span class="string">&#x27;./base.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ensureSlash</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span> = <span class="string">&#x27;/&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getHash</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">HashHistory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">History</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">router</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(router)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化hash路由时，若URL中没有hash，则设置默认的hash路径 /</span></span><br><span class="line">    <span class="title function_">ensureSlash</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">push</span>(<span class="params">location</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置当前路由，随后改变浏览器URL的hash值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">transitionTo</span>(location, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span> = location</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>.&#x2F;src&#x2F;history&#x2F;history.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">History</span> rom <span class="string">&#x27;./base.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">BroswerHistory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">History</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">router</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(router)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">push</span>(<span class="params">location</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里使用 pushState 来改变URL</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">transitionTo</span>(location, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">pushState</span>(&#123;&#125;, <span class="string">&#x27;&#x27;</span>, location)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，需在Router中代理push方法，方便直接调用</p>
<p><strong>.&#x2F;src&#x2F;index.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VueRouter</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">location</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">push</span>(location)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VueRouter初始化"><a href="#VueRouter初始化" class="headerlink" title="VueRouter初始化"></a>VueRouter初始化</h3><p>在创建根实例前，需完成VueRouter初始化，主要包含两个操作：</p>
<ul>
<li>设置当前路径下的路由信息，用于页面组件渲染</li>
<li>设置相关路由事件监听，从而动态设置当前路由信息</li>
</ul>
<p>总之，初始化操作还是服务于后续页面组件的渲染。</p>
<p><strong>.&#x2F;src&#x2F;install.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">install</span>(<span class="params">_Vue</span>) &#123;</span><br><span class="line">  <span class="title class_">Vue</span> = _Vue</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Vue</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">    <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">router</span>) &#123; <span class="comment">// 根实例</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_router</span>.<span class="title function_">init</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>.&#x2F;src&#x2F;index.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VueRouter</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">init</span>(<span class="params">app</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> history = <span class="variable language_">this</span>.<span class="property">history</span></span><br><span class="line">    history.<span class="title function_">transitionTo</span>(history.<span class="title function_">getCurrentLocation</span>(), <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      history.<span class="title function_">setupListener</span>() <span class="comment">// 监听相关URL信息变化</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>.&#x2F;src&#x2F;history&#x2F;hash.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">HashHistory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">History</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">setupListener</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 监听 hashchange 事件，更新 route 信息</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">transitionTo</span>(<span class="variable language_">this</span>.<span class="title function_">getCurrentLocation</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getCurrentLocation</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>.&#x2F;src&#x2F;history&#x2F;history.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">BrowserHistory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">History</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">setupListener</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 监听 popstate 事件，更新 route 信息</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">transitionTo</span>(<span class="variable language_">this</span>.<span class="title function_">getCurrentLocation</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getCurrentLocation</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>可以发现，VueRouter类主要围绕着路径和路由的更新，路由中包含着当前路径下匹配到的所有配置记录，服务于后续页面组件的渲染。</p>
<h2 id="VueRouter组件"><a href="#VueRouter组件" class="headerlink" title="VueRouter组件"></a>VueRouter组件</h2><p>在注册插件时介绍了会注册两个全局组件，这两个组件为：router-link和router-view：</p>
<ul>
<li>前者用于控制页面组件的跳转，类似于<code>a标签</code>，减少开发者代码量</li>
<li>后者用于渲染页面组件，利用了路由信息（this.$route）</li>
</ul>
<h3 id="RouterLink"><a href="#RouterLink" class="headerlink" title="RouterLink"></a>RouterLink</h3><p>Link组件比较简单，可以配置 tag 改变组件在页面上渲染的标签类型，to 则对应要跳转的页面路径。</p>
<p><strong>.&#x2F;src&#x2F;components&#x2F;link.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;RouterLink&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">to</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="attr">tag</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span>, <span class="attr">default</span>: <span class="string">&#x27;a&#x27;</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">to</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">render</span>(<span class="params">h</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(<span class="variable language_">this</span>.<span class="property">tag</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: <span class="variable language_">this</span>.<span class="property">handler</span> &#125; &#125;, <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="property">default</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RouterView"><a href="#RouterView" class="headerlink" title="RouterView"></a>RouterView</h3><p>View组件本身是中间层，它的职责是把对应的页面组件渲染出来，不需要管理状态，因此可以将其声明为函数式组件，根据嵌套层级从路由信息中的match数组中获取对应的页面组件，最终render出去。</p>
<p>有关路由信息可以从父组件中获取，后面会给Vue原型上添加$route属性，用于组件访问当前route实例</p>
<p><strong>.&#x2F;src&#x2F;components&#x2F;view.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;RouterView&#x27;</span>,</span><br><span class="line">  <span class="attr">functional</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="title function_">render</span>(<span class="params">h, &#123; parent, data &#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// 标识当前组件是 RouterView</span></span><br><span class="line">    data.<span class="property">routerView</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 由于函数式组件获取不到this，因此只能通过父组件获取 route</span></span><br><span class="line">    <span class="keyword">const</span> route = parent.<span class="property">$route</span></span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> record = route.<span class="property">matched</span>[depth]</span><br><span class="line">    <span class="comment">// 没有路由记录，渲染空内容</span></span><br><span class="line">    <span class="keyword">if</span> (!record) <span class="keyword">return</span> <span class="title function_">h</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(parent &amp;&amp; parent.<span class="property">_routerRoot</span> !== parent) &#123;</span><br><span class="line">      <span class="comment">// 如果当前父组件是 RouterView，嵌套层级 +1</span></span><br><span class="line">      <span class="keyword">if</span> (parent.<span class="property">$vnode</span>?.<span class="property">data</span>?.<span class="property">routerView</span>) depth++</span><br><span class="line">      parent = parent.<span class="property">$parent</span></span><br><span class="line">    &#125;</span><br><span class="line">    record = route.<span class="property">matched</span>[depth]</span><br><span class="line">    <span class="keyword">if</span> (!record) <span class="keyword">return</span> <span class="title function_">h</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(record.<span class="property">component</span>, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>History</code>基类的transitionTo方法中设置了类成员current值，该值保存着当前路由信息，接下来我们需要将其挂载到根实例上，并使其具有响应式，然后在Vue原型上设置代理属性<code>$route</code>，这样每个组件都可以通过<code>this.$route</code>获取路由信息。</p>
<p><strong>.&#x2F;src&#x2F;install.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">install</span>(<span class="params">_Vue</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">    <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">router</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_router</span>.<span class="title function_">init</span>(<span class="variable language_">this</span>) <span class="comment">// 初始化VueRouter</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给根实例上定义 _route 属性，并使其是响应式对象</span></span><br><span class="line">        <span class="title class_">Vue</span>.<span class="property">util</span>.<span class="title function_">defineReactive</span>(<span class="variable language_">this</span>, <span class="string">&#x27;_route&#x27;</span>, <span class="variable language_">this</span>.<span class="property">_router</span>.<span class="property">history</span>.<span class="property">current</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;$route&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_routerRoot</span>?.<span class="property">_route</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样在<code>history.current</code>改变时不能更新<code>_route</code>，因为这里只是声明<code>_route</code>是响应式的，因此这里还需要做一次代理操作，手动修改<code>_route</code>值。</p>
<p>初始化VueRouter时，可以给<code>History</code>实例传入主动修改<code>_route</code>值的回调函数，并将其保存下来，每次<code>history.transitionTo</code>执行时，同时执行该回调函数。</p>
<p><strong>.&#x2F;src&#x2F;index.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VueRouter</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">init</span>(<span class="params">app</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">listen</span>(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">      app.<span class="property">_route</span> = route</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>.&#x2F;src&#x2F;history&#x2F;base.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">History</span> &#123;</span><br><span class="line">  <span class="title function_">listen</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">transitionTo</span>(<span class="params">location, listener</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    listener &amp;&amp; <span class="title function_">listener</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">cb</span>(<span class="variable language_">this</span>.<span class="property">current</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>路由守卫就是Router上的成员方法<code>beforeEach</code>，该方法接收一个回调函数，每当发生页面跳转时就会执行该回调函数，来决定是否放行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params"><span class="keyword">from</span>, to, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  	<span class="title function_">next</span>()</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params"><span class="keyword">from</span>, to, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="title function_">next</span>()    </span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打开浏览器控制台可以看到依次打印 1和2，可见beforeEach可以多次调用，并依次执行回调函数。其中核心就是发布订阅模式，当执行<code>beforeEach</code>时会将回调函数保存至数组中，在路由跳转前（history.transitionTo）执行数组中的函数。</p>
<p><strong>.&#x2F;src&#x2F;index.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">VueRouter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">beforeEachHooks</span> = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">beforeEach</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">beforeEachHooks</span>.<span class="title function_">push</span>(ch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>.&#x2F;src&#x2F;history&#x2F;base.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">History</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">transitionTo</span>(<span class="params">location, listener</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> record = <span class="variable language_">this</span>.<span class="property">router</span>.<span class="title function_">match</span>(location) <span class="comment">// 获取匹配的路由记录</span></span><br><span class="line">    <span class="keyword">const</span> route = <span class="title function_">createRoute</span>(record, &#123; <span class="attr">path</span>: location &#125;) <span class="comment">// 创建路由实例</span></span><br><span class="line">    <span class="comment">// 只有当前路径改变时才执行后续操作，由于默认是 根路径&#x27;/&#x27;，因此还需根据 matched 数组长度来特判</span></span><br><span class="line">    <span class="keyword">if</span> (location === <span class="variable language_">this</span>.<span class="property">current</span>.<span class="property">path</span> &amp;&amp; route.<span class="property">matched</span>.<span class="property">length</span> === <span class="variable language_">this</span>.<span class="property">current</span>.<span class="property">matched</span>.<span class="property">length</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> queue = [].<span class="title function_">concat</span>(<span class="variable language_">this</span>.<span class="property">router</span>.<span class="property">beforeEachHooks</span>)</span><br><span class="line">    <span class="title function_">runQueue</span>(queue, <span class="variable language_">this</span>.<span class="property">current</span>, route, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">current</span> = route</span><br><span class="line">      listener &amp;&amp; <span class="title function_">listener</span>()</span><br><span class="line">      <span class="comment">// 更新根实例 app._route</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cb</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">cb</span>(route)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">runQueue</span>(<span class="params">queue, <span class="keyword">from</span> , to, cb</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= queue.<span class="property">length</span>) <span class="keyword">return</span> <span class="title function_">cb</span>()</span><br><span class="line">    <span class="keyword">const</span> hook = queue[index]</span><br><span class="line">    <span class="title function_">hook</span>(<span class="keyword">from</span>, to, <span class="function">() =&gt;</span> <span class="title function_">next</span>(index + <span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>runQueue</code>方法会根据当前索引执行路由守卫函数，当索引值为数组长度时则执行回调。</p>
]]></content>
      <categories>
        <category>Vue系列源码</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
        <tag>VueRouter源码</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着React官网学习1--画页面</title>
    <url>/11b19440/</url>
    <content><![CDATA[<blockquote>
<p>网上关于React的教程层出不穷，加上教学者的个人理解，对于初学者不太友好。当前React官网已经更新，里面的教程比较全面且权威，接下来本人将跟着官网从零开始学习React，并在学习过程中思考它和Vue3的区别。</p>
</blockquote>
<span id="more"></span>

<h1 id="第一个组件"><a href="#第一个组件" class="headerlink" title="第一个组件"></a>第一个组件</h1><blockquote>
<p>无论React还是Vue，它们的核心思想都是组件化，这是构建用户交互界面的基础。组件化的好处是抽离可复用的页面元素和交互逻辑，提高开发效率；另外这让单页面应用的路由切换不需要经过服务端处理，做到真正的前后端分离。</p>
</blockquote>
<p>不同于HTML，React组件除了可以使用HTML标签，还可以复用其他React组件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;PageLayout&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">  	&lt;SearchBar&gt;&lt;/SearchBar&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">  	&lt;PageContent&gt;&lt;/PageContent&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/PageLayout&gt;</span><br></pre></td></tr></table></figure>

<h2 id="定义一个组件"><a href="#定义一个组件" class="headerlink" title="定义一个组件"></a>定义一个组件</h2><p>React为了接近原生开发体验，将页面交互逻辑和页面结构集成至js中，一个组件就是一个js方法，其写法如下：</p>
<p><strong>Profile.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function Profile() &#123;</span><br><span class="line">  return (</span><br><span class="line">  	&lt;img</span><br><span class="line">      src=&quot;https://i.imgur.com/MK3eW3Am.jpg&quot;</span><br><span class="line">      alt=&quot;Katherine Johnson&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出其主要包含三个步骤：</p>
<ul>
<li>使用<code>export</code>导出定义的组件</li>
<li>使用<code>funciton</code>声明组件，其中函数名首字母大写</li>
<li>在函数里面编写相应的交互逻辑，并最后返回标签元素</li>
</ul>
<p>需要注意的是：<strong>如果函数返回的内容超过一行，可使用括号包裹换行，否则会被忽略</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这样写是正确的</span><br><span class="line">return (</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">  	&lt;img src=&quot;test.jpg&quot;&gt;&lt;/img&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line">// 这样也行，最好还是第一种写法</span><br><span class="line">return &lt;div&gt;</span><br><span class="line">		&lt;img src=&quot;&quot;&gt;&lt;/img&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// 这样是错误的</span><br><span class="line">return </span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;img src=&quot;&quot;&gt;&lt;/img&gt;</span><br><span class="line">	&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h2><p>组件使用的方式有两种：</p>
<ul>
<li>在当前文件中定义一个组件，直接使用</li>
<li>导入其他文件中定义的组件，然后使用</li>
</ul>
<p>前面已经在<code>Profile.js</code>中定义了一个组件并导出，我们可以将其导入并嵌入组件使用，例如当前组件需要展示多个<code>Profile</code>组件</p>
<p><strong>App.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 导入组件</span><br><span class="line">import Profile from &#x27;./Profile.js&#x27;</span><br><span class="line">export default function Gallery() &#123;</span><br><span class="line">  return (</span><br><span class="line">  	&lt;section&gt;</span><br><span class="line">    	&lt;h1&gt;Amazing scientists&lt;/h1&gt;</span><br><span class="line">      &lt;Profile /&gt;</span><br><span class="line">      &lt;Profile /&gt;</span><br><span class="line">      &lt;Profile /&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用JSX编写标签"><a href="#使用JSX编写标签" class="headerlink" title="使用JSX编写标签"></a>使用JSX编写标签</h1><blockquote>
<p>前面提过，React把编写页面标签的部分也放到js文件中，JSX发挥着重要作用，它是JavaScript的增强版，在支持js语法的同时，还能编写类HTML标签。</p>
</blockquote>
<h2 id="JSX：标签嵌入JavaScript"><a href="#JSX：标签嵌入JavaScript" class="headerlink" title="JSX：标签嵌入JavaScript"></a>JSX：标签嵌入JavaScript</h2><p>Web页面通常由HTML、CSS和JavaScript构成，HTML用来构建文档结构，CSS用来润色样式，JavaScript处理页面交互，它们由相应的标签引入到HTML文件中：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304201859105.png" alt="image-20230420185917069"></p>
<p>但随着页面功能越来越多，其结构杂糅混乱，后期较难维护。所以React把页面标签和交互操作统一由函数组件管理。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304201859653.png" alt="image-20230420185931619"></p>
<h2 id="JSX语法规则"><a href="#JSX语法规则" class="headerlink" title="JSX语法规则"></a>JSX语法规则</h2><h3 id="返回单个根元素"><a href="#返回单个根元素" class="headerlink" title="返回单个根元素"></a>返回单个根元素</h3><p>如果组件返回多个元素，则需要用一个父元素将其包裹，比如可以使用<code>&lt;div&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">  &lt;img /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>如果不想改变DOM结构，则可以使用空标签<code>&lt;&gt;&lt;/&gt;</code>，也被称为<code>Fragment</code>组件，它不会改变DOM树结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&gt;</span><br><span class="line">	&lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">  &lt;img /&gt;</span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="闭合所有标签"><a href="#闭合所有标签" class="headerlink" title="闭合所有标签"></a>闭合所有标签</h3><p>JSX要求所有标签严格闭合：比如自闭和标签<code>&lt;img&gt;</code>必须写成<code>&lt;img /&gt;</code>，一般标签<code>&lt;li&gt;oranges</code>必须写成<code>&lt;li&gt;orange&lt;/li&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&gt;</span><br><span class="line">  &lt;img /&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;Invent new traffic lights&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;Rehearse a movie scene&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;Improve the spectrum technology&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="驼峰命名"><a href="#驼峰命名" class="headerlink" title="驼峰命名"></a>驼峰命名</h3><p>无论是在组件中定义变量还是给组件标签设置属性时，应使用驼峰命名。特殊的，给标签声明类名时应把<code>class</code>改为<code>className</code>，因为<code>class</code>为JavaScript的关键字，JSX转为JS时会将其转为对象，其中标签属性就是对象的属性名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img </span><br><span class="line">  src=&quot;https://i.imgur.com/yXOvdOSs.jpg&quot; </span><br><span class="line">  alt=&quot;Hedy Lamarr&quot; </span><br><span class="line">  className=&quot;photo&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：由于历史原因，<code>aria-*</code>和<code>data-*</code>属性还是写成在HTML中的形式。</p>
<h2 id="进阶：使用JSX转换器"><a href="#进阶：使用JSX转换器" class="headerlink" title="进阶：使用JSX转换器"></a>进阶：使用JSX转换器</h2><p>可以使用<a href="https://transform.tools/html-to-jsx">converter</a>批量转换HTML，这也有助于理解JSX语法规则。</p>
<blockquote>
<p>原生HTML</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hedy Lamarr&#x27;s Todos<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://i.imgur.com/yXOvdOSs.jpg&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">&quot;Hedy Lamarr&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;photo&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Invent new traffic lights</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Rehearse a movie scene</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Improve the spectrum technology</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用JSX转换器后的JSX</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&gt;</span><br><span class="line">  &lt;h1&gt;Hedy Lamarr&#x27;s Todos&lt;/h1&gt;</span><br><span class="line">  &lt;img</span><br><span class="line">    src=&quot;https://i.imgur.com/yXOvdOSs.jpg&quot;</span><br><span class="line">    alt=&quot;Hedy Lamarr&quot;</span><br><span class="line">    className=&quot;photo&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;Invent new traffic lights&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;Rehearse a movie scene&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;Improve the spectrum technology&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="在JSX中加点JS代码"><a href="#在JSX中加点JS代码" class="headerlink" title="在JSX中加点JS代码"></a>在JSX中加点JS代码</h1><blockquote>
<p>JS中可以使用JSX编写类HTML标记，页面渲染和交互逻辑可以同时处理。有时候可能还想在JSX加点JS代码或展示变量，这时候可以使用大括号包裹。</p>
</blockquote>
<p>在JSX中如果想给标签属性传入变量可以使用<code>&#123;&#125;</code>，比如我想给<code>img</code>标签的<code>src</code>和<code>alt</code>传值，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function Avatar() &#123;</span><br><span class="line">  const avatar = &#x27;https://i.imgur.com/7vQD0fPs.jpg&#x27;;</span><br><span class="line">  const description = &#x27;Gregorio Y. Zara&#x27;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;img</span><br><span class="line">      className=&quot;avatar&quot;</span><br><span class="line">      src=&#123;avatar&#125;</span><br><span class="line">      alt=&#123;description&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果传入引号包裹的内容，则值类型为字符串，值就是引号中的内容；而传入<code>&#123;&#125;</code>包裹的内容，值类型和变量有关，值执行变量的值。</p>
<p>JSX不仅可以给标签属性传值，还可以给标签内容动态传值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function TodoList() &#123;</span><br><span class="line">  const name = &#x27;Gregorio Y. Zara&#x27;</span><br><span class="line">  return &lt;h1&gt;&#123;name&#125;&#x27;s To Do List&lt;/h1&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以执行JS函数，获取函数返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const today = new Date();</span><br><span class="line"></span><br><span class="line">function formatDate(date) &#123;</span><br><span class="line">  return new Intl.DateTimeFormat(</span><br><span class="line">    &#x27;en-US&#x27;,</span><br><span class="line">    &#123; weekday: &#x27;long&#x27; &#125;</span><br><span class="line">  ).format(date);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function TodoList() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;h1&gt;To Do List for &#123;formatDate(today)&#125;&lt;/h1&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是</strong>：在JSX中编写行内行内样式得以对象的形式定义。比如我要自定义<code>&lt;ul&gt;</code>标签的行内样式，需写成以下形式（注意驼峰命名）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function TodoList() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul style=&#123;&#123;</span><br><span class="line">      backgroundColor: &#x27;black&#x27;,</span><br><span class="line">      color: &#x27;pink&#x27;</span><br><span class="line">    &#125;&#125;&gt;</span><br><span class="line">      &lt;li&gt;Improve the videophone&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;Prepare aeronautics lectures&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;Work on the alcohol-fuelled engine&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>&#123;&#123;&#125;&#125;</code>形式，本质上就是给<code>style</code>属性传入一个JS对象。</p>
<h1 id="给组件传入Props"><a href="#给组件传入Props" class="headerlink" title="给组件传入Props"></a>给组件传入Props</h1><blockquote>
<p>React组件使用props和其他组件进行通信。每个父组件可以通过props给子组件传递信息，从而完成父子组件通信。</p>
</blockquote>
<p>props就是传递给JSX标签的信息，比如可以给<code>img</code>设置<code>className</code>, <code>src</code>,<code>alt</code>,<code>width</code>等，这些就是props。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Avatar() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;img</span><br><span class="line">      className=&quot;avatar&quot;</span><br><span class="line">      src=&quot;https://i.imgur.com/1bX5QH6.jpg&quot;</span><br><span class="line">      alt=&quot;Lin Lanying&quot;</span><br><span class="line">      width=&#123;100&#125;</span><br><span class="line">      height=&#123;100&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些传给<code>img</code>的props是预定义的，也可以传入任何自定义props到组件中，这通常包括两步：</p>
<ol>
<li><p>给子组件传入props</p>
<p>比如我想给<code>Avatar</code>组件传入两个props：person（对象）和size（数字）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function Profile() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Avatar</span><br><span class="line">      person=&#123;&#123; name: &#x27;Lin Lanying&#x27;, imageId: &#x27;1bX5QH6&#x27; &#125;&#125;</span><br><span class="line">      size=&#123;100&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件中读取props</p>
<p>props会作为子组件函数的函数以对象的形式传入，可以直接解构使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Avatar(&#123; person, size &#125;) &#123;</span><br><span class="line">  // 这里可以使用 person 和 size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="给prop设置默认值"><a href="#给prop设置默认值" class="headerlink" title="给prop设置默认值"></a>给prop设置默认值</h2><p>有时候使用组件时有默认的行为，这时可以给prop设置默认值，既不会破坏组件自定义也可以使用默认值。</p>
<p>比如<code>Avatar</code>中的<code>size</code>默认为100，可以这样设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Avatar(&#123; person, size = 100 &#125;) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用扩展运算符转发prop"><a href="#使用扩展运算符转发prop" class="headerlink" title="使用扩展运算符转发prop"></a>使用扩展运算符转发prop</h2><p>当组件props变多时，转发prop变得重复性，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Profile(&#123; person, size, isSepia, thickBorder &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">      &lt;Avatar</span><br><span class="line">        person=&#123;person&#125;</span><br><span class="line">        size=&#123;size&#125;</span><br><span class="line">        isSepia=&#123;isSepia&#125;</span><br><span class="line">        thickBorder=&#123;thickBorder&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用扩展运算符<code>...</code>简化操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Profile(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">      &lt;Avatar &#123;...props&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JSX作为children传递"><a href="#JSX作为children传递" class="headerlink" title="JSX作为children传递"></a>JSX作为children传递</h2><p>HTML中标签套标签是比较常见的：<code>&lt;div&gt;&lt;img /&gt;&lt;/div&gt;</code>。</p>
<p>JSX也可以实现组件的内嵌，它会被设置为<code>props.children</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Avatar from &#x27;./Avatar.js&#x27;;</span><br><span class="line"></span><br><span class="line">function Card(&#123; children &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function Profile() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Card&gt;</span><br><span class="line">      &lt;Avatar</span><br><span class="line">        size=&#123;100&#125;</span><br><span class="line">        person=&#123;&#123; </span><br><span class="line">          name: &#x27;Katsuko Saruhashi&#x27;,</span><br><span class="line">          imageId: &#x27;YfeOqp2&#x27;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Vue中则是通过插槽（slot）实现。</p>
<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><blockquote>
<p>组件中通常想根据不同条件展示不同内容。在React中，可以使用if语句、&amp;&amp;、三元运算符（? : ）来条件渲染JSX。</p>
</blockquote>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Item(&#123; name, isPacked &#125;) &#123;</span><br><span class="line">  if (isPacked) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;li className=&quot;item&quot;&gt;&#123;name&#125;&lt;/li&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function PackingList() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;h1&gt;Sally Ride&#x27;s Packing List&lt;/h1&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;Item </span><br><span class="line">          isPacked=&#123;true&#125; </span><br><span class="line">          name=&quot;Space suit&quot; </span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;Item </span><br><span class="line">          isPacked=&#123;true&#125; </span><br><span class="line">          name=&quot;Helmet with a golden leaf&quot; </span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;Item </span><br><span class="line">          isPacked=&#123;false&#125; </span><br><span class="line">          name=&quot;Photo of Tam&quot; </span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逻辑与-amp-amp"><a href="#逻辑与-amp-amp" class="headerlink" title="逻辑与 &amp;&amp;"></a>逻辑与 &amp;&amp;</h2><p>JSX中，<code>&#123;cond &amp;&amp; &lt;A /&gt;&#125;</code> 表示 <em>“如果 <code>cond</code> 为真, 渲染 <code>&lt;A /&gt;</code>, 否则为空”</em>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Item(&#123; name, isPacked &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;li className=&quot;item&quot;&gt;</span><br><span class="line">      &#123;name&#125; &#123;isPacked &amp;&amp; &#x27;✔&#x27;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>JSX中, <code>&#123;cond ? &lt;A /&gt; : &lt;B /&gt;&#125;</code> 表示 <em>“如果 <code>cond</code> 为真, 渲染 <code>&lt;A /&gt;</code>, 否则渲染 <code>&lt;B /&gt;</code>”</em>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Item(&#123; name, isPacked &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;li className=&quot;item&quot;&gt;</span><br><span class="line">      &#123;isPacked ? (</span><br><span class="line">        &lt;del&gt;</span><br><span class="line">          &#123;name + &#x27; ✔&#x27;&#125;</span><br><span class="line">        &lt;/del&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        name</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="渲染列表"><a href="#渲染列表" class="headerlink" title="渲染列表"></a>渲染列表</h1><blockquote>
<p>根据已有的数据渲染多个组件是常见的，我们可以使用JS中的数组方法来完成相应的组件渲染，在React中<code>filter()</code>和<code>map()</code>函数通常过滤数据，把数组中的数据转为组件。</p>
</blockquote>
<h2 id="从数组中批量渲染JSX"><a href="#从数组中批量渲染JSX" class="headerlink" title="从数组中批量渲染JSX"></a>从数组中批量渲染JSX</h2><p>比如我要把<code>people数组</code>的内容以<code>&lt;li&gt;</code>标签的形式展示出来，可以使用<code>map()</code>方法转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const people = [</span><br><span class="line">  &#x27;Creola Katherine Johnson: mathematician&#x27;,</span><br><span class="line">  &#x27;Mario José Molina-Pasquel Henríquez: chemist&#x27;,</span><br><span class="line">  &#x27;Mohammad Abdus Salam: physicist&#x27;,</span><br><span class="line">  &#x27;Percy Lavon Julian: chemist&#x27;,</span><br><span class="line">  &#x27;Subrahmanyan Chandrasekhar: astrophysicist&#x27;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export default function List() &#123;</span><br><span class="line">  const listItems = people.map(person =&gt;</span><br><span class="line">    &lt;li&gt;&#123;person&#125;&lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">  return &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过滤数组中非法数据"><a href="#过滤数组中非法数据" class="headerlink" title="过滤数组中非法数据"></a>过滤数组中非法数据</h2><p>可以先使用<code>filter()</code>方法得到需要展示的数据，然后用<code>map()</code>方法转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; people &#125; from &#x27;./data.js&#x27;;</span><br><span class="line">import &#123; getImageUrl &#125; from &#x27;./utils.js&#x27;;</span><br><span class="line"></span><br><span class="line">export default function List() &#123;</span><br><span class="line">  const chemists = people.filter(person =&gt;</span><br><span class="line">    person.profession === &#x27;chemist&#x27;</span><br><span class="line">  );</span><br><span class="line">  const listItems = chemists.map(person =&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;img</span><br><span class="line">        src=&#123;getImageUrl(person)&#125;</span><br><span class="line">        alt=&#123;person.name&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;b&gt;&#123;person.name&#125;:&lt;/b&gt;</span><br><span class="line">        &#123;&#x27; &#x27; + person.profession + &#x27; &#x27;&#125;</span><br><span class="line">        known for &#123;person.accomplishment&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">  return &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="给JSX列表项设置key"><a href="#给JSX列表项设置key" class="headerlink" title="给JSX列表项设置key"></a>给JSX列表项设置<code>key</code></h2><p>在JSX中，key在列表项中作为唯一标识符，合理的设置key可以提升渲染性能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;li key=&#123;person.id&#125;&gt;...&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<p>之前提到过，JSX中需要用一个根标签包裹，比如<code>&lt;div&gt;</code>，也可以使用空标签<code>&lt;&gt;&lt;/&gt;</code>，不会改变DOM结构。在渲染列表时，由于要给列表项设置key，此时不能直接对<code>&lt;&gt;&lt;/&gt;</code>设置props，可以引入<code>&lt;Fragment&gt;</code>组件，达到相同的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; Fragment &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">const listItems = people.map(person =&gt;</span><br><span class="line">  &lt;Fragment key=&#123;person.id&#125;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;person.name&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;&#123;person.bio&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/Fragment&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是</strong>：</p>
<ul>
<li>兄弟标签之间key必须是唯一的</li>
<li>key必须是不可变的（不能这样设置：<code>&lt;li key=&#123;random()&#125;&gt;</code>，每次渲染时都会生成不同的key）</li>
</ul>
<h1 id="纯组件"><a href="#纯组件" class="headerlink" title="纯组件"></a>纯组件</h1><blockquote>
<p>React中的组件为函数式组件，故纯组件也叫纯函数。纯函数仅执行计算，严格按照纯函数的标准声明组件可以避免一系列bug随着代码量增加。</p>
</blockquote>
]]></content>
      <categories>
        <category>跟着官网学习React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>从0到1写一个接口</title>
    <url>/d7b48b88/</url>
    <content><![CDATA[<blockquote>
<p>记录从零到一使用IDEA搭建SpringBoot后端项目</p>
</blockquote>
<span id="more"></span>

<h1 id="一：新建项目"><a href="#一：新建项目" class="headerlink" title="一：新建项目"></a>一：新建项目</h1><h2 id="1-打开-IDEA-新建项目"><a href="#1-打开-IDEA-新建项目" class="headerlink" title="1. 打开 IDEA 新建项目"></a>1. 打开 IDEA 新建项目</h2><p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304212127417.png" alt="image-20230420195137587"></p>
<p>其中英文名称释义</p>
<ul>
<li><code>Name</code>：项目名称</li>
<li><code>Location</code>：代码位置</li>
<li><code>Language</code>：编程语言</li>
<li><code>Build system</code>：这里指的是项目的构建方式，此处我选择的是 Maven</li>
<li><code>GroupId</code>：项目组织唯一的标识符</li>
<li><code>ArtifactID</code>：项目的唯一的标识符</li>
</ul>
<h2 id="2-添加依赖"><a href="#2-添加依赖" class="headerlink" title="2. 添加依赖"></a>2. 添加依赖</h2><p>往<code>pom.xml</code>文件中添加代码，添加后的<code>pom.xml</code>文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在<code>pom.xml</code>中右键点击<code>maven-&gt;Reload project</code></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304212127738.jpg" alt="Screenshot 2023-04-20 at 20.04.23"></p>
<p>点击后，如果项目中的<code>External Libraries</code>目录中包含如下内容，说明依赖添加成功</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304212127391.jpg" alt="Screenshot 2023-04-20 at 20.05.55"></p>
<h2 id="3-配置文件设置"><a href="#3-配置文件设置" class="headerlink" title="3. 配置文件设置"></a>3. 配置文件设置</h2><p>在<code>src/main/resources</code>目录下创建一个<code>application.yml</code>文件，填写内容如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">数据库用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">数据库密码</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span></span><br></pre></td></tr></table></figure>

<h2 id="4-创建程序入口类"><a href="#4-创建程序入口类" class="headerlink" title="4. 创建程序入口类"></a>4. 创建程序入口类</h2><ol>
<li><p>在<code>src/main/java</code>目录创建<code>org.example.demo</code>包</p>
</li>
<li><p>在<code>src/main/java/org/example/demo</code>目录下创建程序入口类<code>DemoApplication.java</code>,内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-启动项目"><a href="#5-启动项目" class="headerlink" title="5. 启动项目"></a>5. 启动项目</h2><p>在完成前面步骤后，此时的目录结构如下：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304212127592.png" alt="image-20230420203532628"></p>
<p>点击运行<code>DemoApplication.java</code>，如果出现如下内容，说明项目启动成功。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304212127578.jpg" alt="Screenshot 2023-04-20 at 20.30.31"></p>
<h1 id="二：理解是什么MVC"><a href="#二：理解是什么MVC" class="headerlink" title="二：理解是什么MVC"></a>二：理解是什么MVC</h1><h2 id="1-view-controller-model"><a href="#1-view-controller-model" class="headerlink" title="1. view-controller-model"></a>1. view-controller-model</h2><p>按照用户请求的执行顺序应该从左向右依次为view-controller-model。</p>
<ul>
<li>视图层view：用于展示数据，与用户进行交互。</li>
<li>控制层controller：用于分发控制到来的请求,并调用模型层与数据库进行交互,以及将数据返回给视图层展示</li>
<li>模型层model：数据模型，它与数据库进行交互，进行CURD操作。</li>
</ul>
<p>如下图：</p>
<p><img data-src="https://naiswang.oss-cn-shanghai.aliyuncs.com/images/image-20230420225337532.png" alt="image-20230420225337532"></p>
<p>这里模拟一个用户查询和新增的请求。<br>当用户通过浏览器的web界面发起查询请求时，首先会被控制层controller分发，然后会调取相应的model层进行数据库查询。然后model层再将数据库查询到的数据返回给控制层，控制层再将其返回view层，view层web页面中进行显示。</p>
<h2 id="2-view-controller-service-dao"><a href="#2-view-controller-service-dao" class="headerlink" title="2. view-controller-service-dao"></a>2. view-controller-service-dao</h2><p>随着项目业务逻辑越来越复杂，单用model层会使得该层变得越来越臃肿。为了解决这个问题，可以将model层拆分成2层，分别是service层，与dao层。那么上述的情景就可以有如下的表示：</p>
<p><img data-src="https://naiswang.oss-cn-shanghai.aliyuncs.com/images/image-20230420225405211.png" alt="image-20230420225405211"></p>
<ul>
<li>视图层view：用于展示数据，与用户进行交互。</li>
<li>控制层controller：用于分发控制到来的请求,并将请求分发给相应的业务层。以及将数据返回给视图层展示。</li>
<li>业务层service：业务处理，调用数据访问层与数据库进行交互。</li>
<li>数据访问层dao：它与数据库进行交互，封装了对数据库的CURD操作。</li>
</ul>
<p>当请求来了，controller就会将相应的请求分发到相应的service层，在service层中再调用dao层进行数据库交互。这里的dao层其实就是之前的model层，封装了对数据库的操作。这样一来，就把业务处理逻辑从controller中分离出来，从而实现了解耦。</p>
<h1 id="三：创建第一个Controller"><a href="#三：创建第一个Controller" class="headerlink" title="三：创建第一个Controller"></a>三：创建第一个Controller</h1><h2 id="1-创建controller类"><a href="#1-创建controller类" class="headerlink" title="1. 创建controller类"></a>1. 创建controller类</h2><ol>
<li><p>在<code>src/main/java/org/example/demo</code>目录下创建<code>controller</code>包</p>
</li>
<li><p>在<code>src/main/java/org/example/demo/controller</code>目录下创建<code>DemoContoller.java</code>类，往其中添加如下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-测试"><a href="#2-测试" class="headerlink" title="2. 测试"></a>2. 测试</h2><ol>
<li><p>运行项目</p>
</li>
<li><p>打开浏览器，访问<code>localhost:8080/hello</code>，效果如下</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304212127094.png" alt="image-20230420222747486"></p>
</li>
</ol>
</li>
</ol>
<h1 id="四：实现查"><a href="#四：实现查" class="headerlink" title="四：实现查"></a>四：实现查</h1><blockquote>
<p> 要求：实现一个读数据库的接口，该接口的功能：根据传入的学生编号number返回学生信息</p>
</blockquote>
<h2 id="1-创建student表"><a href="#1-创建student表" class="headerlink" title="1. 创建student表"></a>1. 创建<code>student</code>表</h2><p>建表sql语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use test;</span><br><span class="line"></span><br><span class="line">create table if not exists student</span><br><span class="line">(</span><br><span class="line">    id     int         not null primary key,</span><br><span class="line">    age    int         not null comment &#x27;年龄&#x27;,</span><br><span class="line">    number varchar(20) not null comment &#x27;学生编号&#x27;,</span><br><span class="line">    name   varchar(20) null comment &#x27;学生姓名&#x27;,</span><br><span class="line">    constraint student_pk unique (number)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test.student (id, age, number, name) VALUES (1, 0, &#x27;M202101&#x27;, &#x27;张三&#x27;);</span><br><span class="line">INSERT INTO test.student (id, age, number, name) VALUES (2, 0, &#x27;M202102&#x27;, &#x27;王武&#x27;);</span><br><span class="line">INSERT INTO test.student (id, age, number, name) VALUES (3, 0, &#x27;M202103&#x27;, &#x27;赵六&#x27;);</span><br><span class="line">INSERT INTO test.student (id, age, number, name) VALUES (4, 0, &#x27;M202104&#x27;, &#x27;李四&#x27;);</span><br></pre></td></tr></table></figure>

<p>运行上述sql后，会创建一个<code>student</code>表，并且往其中插入了4条数据。效果如下：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304212128220.png" alt="image-20230420224530501"></p>
<h2 id="2-实现Dao层代码"><a href="#2-实现Dao层代码" class="headerlink" title="2. 实现Dao层代码"></a>2. 实现Dao层代码</h2><h3 id="2-1-创建DO类"><a href="#2-1-创建DO类" class="headerlink" title="2.1. 创建DO类"></a>2.1. 创建DO类</h3><ol>
<li><p>在<code>src/main/java/org/example/demo</code>目录下创建一个<code>DO</code>包</p>
</li>
<li><p>在<code>src/main/java/org/example/demo/DO</code>包下创建<code>StudentDO</code>类，该类中的属性与数据库表字段一一对应。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 学生编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 年龄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(String number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-创建Mapper接口"><a href="#2-2-创建Mapper接口" class="headerlink" title="2.2. 创建Mapper接口"></a>2.2. 创建Mapper接口</h3><ol>
<li>在<code>src/main/java/org/example/demo</code>目录下创建<code>mapper</code>包</li>
<li>在<code>src/main/java/org/example/demo/mapper</code>包下创建<code>StudentMapper.java</code>接口</li>
<li>在<code>StudentMapper.java</code>接口中写上查询函数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据学生编号查询学生信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number 学生编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 根据学生编号查询到的学生信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    StudentDO <span class="title function_">queryStudentByNumber</span><span class="params">(String number)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-创建Mapper-xml配置文件"><a href="#2-3-创建Mapper-xml配置文件" class="headerlink" title="2.3. 创建Mapper.xml配置文件"></a>2.3. 创建Mapper.xml配置文件</h3><ol>
<li>在<code>src/main/resources</code>目录下创建一个<code>mapper</code>包</li>
<li>在<code>src/main/resources/mapper</code>目录下创建<code>StudentMapper.xml</code></li>
<li>将<code>StuentMapper.xml</code>与<code>StudentMapper.java</code> 文件对应起来，并且在<code>StudentMapper.xml</code>中写上<code>StduentMapper.java</code>文件中<code>queryStudentByNumber(String number)</code>方法对应的sql语句</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.example.demo.mapper.StudentMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryStudentByNumber&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.demo.DO.StudentDO&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from student</span><br><span class="line">        where number = #&#123;number&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-实现Service层"><a href="#3-实现Service层" class="headerlink" title="3. 实现Service层"></a>3. 实现Service层</h2><h3 id="3-1-创建Service接口"><a href="#3-1-创建Service接口" class="headerlink" title="3.1. 创建Service接口"></a>3.1. 创建Service接口</h3><ol>
<li>在<code>src/main/java/org/example/demo</code>目录下创建<code>service</code>包</li>
<li>在<code>src/main/java/org/example/demo/service</code>包下创建<code>StudentService.java</code>接口</li>
<li>在<code>StudentService.java</code>接口中写上查询函数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据学生编号查询学生信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number 学生编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 根据学生编号查询到的学生信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    StudentDO <span class="title function_">queryStudentByNumber</span><span class="params">(String number)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-实现Service接口"><a href="#3-2-实现Service接口" class="headerlink" title="3.2. 实现Service接口"></a>3.2. 实现Service接口</h3><ol>
<li>在<code>src/main/java/org/example/demo/service</code>包下创建<code>impl</code>包</li>
<li>在<code>src/main/java/org/example/demo/service/impl</code>包下创建<code>StudentServiceImpl.java</code>类</li>
<li>在<code>StudentServiceImpl.java</code>类中实现<code>StudentService.java</code>接口中的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentMapper studentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StudentDO <span class="title function_">queryStudentByNumber</span><span class="params">(String number)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="literal">null</span> || number.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> studentMapper.queryStudentByNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-实现Controller层"><a href="#4-实现Controller层" class="headerlink" title="4. 实现Controller层"></a>4. 实现Controller层</h2><ol>
<li>在<code>src/main/java/org/example/demo/controller</code>包下创建<code>StudentController.java</code>类</li>
<li>在<code>StudetController.java</code>中实现读数据库的接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentServiceImpl studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/student/queryByNumber&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> StudentDO <span class="title function_">queryByNumber</span><span class="params">(String number)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> studentService.queryStudentByNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h2><ol>
<li><p>运行项目</p>
</li>
<li><p>在浏览器中输入<code>http://localhost:8080/student/queryByNumber?number=M202101</code>，可以看到返回了学生信息</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304212128678.png" alt="image-20230420234518373"></p>
</li>
</ol>
<h1 id="五：实现增"><a href="#五：实现增" class="headerlink" title="五：实现增"></a>五：实现增</h1><blockquote>
<p>要求：实现一个能够新增学生的接口</p>
</blockquote>
<h2 id="1-实现Dao层代码"><a href="#1-实现Dao层代码" class="headerlink" title="1. 实现Dao层代码"></a>1. 实现Dao层代码</h2><ol>
<li><p>在<code>StudentMapper.java</code>接口中写上新增函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增学生</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 影响的数据库行数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addStudent</span><span class="params">(StudentDO student)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>StudentMapper.xml</code>中写上<code>StduentMapper.java</code>文件中<code>addStudent(StudentDO student)</code>方法对应的sql语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addStudent&quot;</span>&gt;</span></span><br><span class="line">    insert into student (id, number, name, age)</span><br><span class="line">    values (#&#123;id&#125;, #&#123;number&#125;, #&#123;name&#125;, #&#123;age&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-实现Service层"><a href="#2-实现Service层" class="headerlink" title="2. 实现Service层"></a>2. 实现Service层</h2><ol>
<li><p>在<code>StudentService.java</code>接口中写上新增函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增学生</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否新增成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addStudent</span><span class="params">(StudentDO student)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>StudentServiceImpl.java</code>类中实现<code>StudentService.java</code>接口中<code>addStudent(StudentDO student)</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addStudent</span><span class="params">(StudentDO student)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> studentMapper.addStudent(student) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-实现Controller层"><a href="#3-实现Controller层" class="headerlink" title="3. 实现Controller层"></a>3. 实现Controller层</h2><p>在<code>StudetController.java</code>中写上新增学生的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/student/add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addStudent</span><span class="params">(Integer id, String number, String name, Integer age)</span> &#123;</span><br><span class="line">    <span class="type">StudentDO</span> <span class="variable">studentDO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentDO</span>();</span><br><span class="line">    studentDO.setId(id);</span><br><span class="line">    studentDO.setNumber(number);</span><br><span class="line">    studentDO.setName(name);</span><br><span class="line">    studentDO.setAge(age);</span><br><span class="line">    <span class="keyword">return</span> studentService.addStudent(studentDO) ? <span class="string">&quot;新增成功&quot;</span> : <span class="string">&quot;新增失败&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>使用<code>postman</code> 模拟发送<code>&quot;/student/add&quot;请求</code></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304212128901.jpg" alt="Screenshot 2023-04-21 at 00.06.24"></p>
<p>查看数据库，可以看到新增了一条数据</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304212128998.jpg" alt="Screenshot 2023-04-21 at 00.07.38"></p>
<h1 id="六：实现删"><a href="#六：实现删" class="headerlink" title="六：实现删"></a>六：实现删</h1><blockquote>
<p>要求：实现一个能够根据学生编号删除学生的接口</p>
</blockquote>
<h2 id="1-实现Dao层代码-1"><a href="#1-实现Dao层代码-1" class="headerlink" title="1. 实现Dao层代码"></a>1. 实现Dao层代码</h2><ol>
<li>在<code>StudentMapper.java</code>接口中写上删除函数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据学生编号删除学生信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> number 学生编号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 影响数据库的行数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteStudentByNumber</span><span class="params">(String number)</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在<code>StudentMapper.xml</code>中写上<code>StduentMapper.java</code>文件中<code>deleteStudentByNumber(String number)</code>方法对应的sql语句</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteStudentByNumber&quot;</span>&gt;</span></span><br><span class="line">    DELETE</span><br><span class="line">    FROM student</span><br><span class="line">    WHERE number = #&#123;number&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-实现Service层-1"><a href="#2-实现Service层-1" class="headerlink" title="2. 实现Service层"></a>2. 实现Service层</h2><ol>
<li><p>在<code>StudentService.java</code>接口中写上删除函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据学生编号删除学生信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> number 学生编号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否删除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">deleteStudentByNumber</span><span class="params">(String number)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>StudentServiceImpl.java</code>类中实现<code>StudentService.java</code>接口中<code>deleteStudentByNumber(String number)</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteStudentByNumber</span><span class="params">(String number)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (number == <span class="literal">null</span> || number.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> studentMapper.deleteStudentByNumber(number) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-实现Controller层-1"><a href="#3-实现Controller层-1" class="headerlink" title="3. 实现Controller层"></a>3. 实现Controller层</h2><p>在<code>StudetController.java</code>中写上删除学生的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/student/deleteStudentByNumber&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteStudentByNumber</span><span class="params">(String number)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> studentService.deleteStudentByNumber(number) ? <span class="string">&quot;删除成功&quot;</span> : <span class="string">&quot;删除失败&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-测试-1"><a href="#4-测试-1" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>使用<code>postman</code> 模拟发送<code>&quot;/student/deleteStudentByNumber&quot;请求</code></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304212128078.jpg" alt="Screenshot 2023-04-21 at 00.22.58"></p>
<p>查看数据库，可以看到没有了学生编号为M202101的数据</p>
<h1 id="七：实现改"><a href="#七：实现改" class="headerlink" title="七：实现改"></a>七：实现改</h1><blockquote>
<p>要求：实现一个根据学生编号修改年龄的接口</p>
</blockquote>
<h2 id="1-实现Dao层代码-2"><a href="#1-实现Dao层代码-2" class="headerlink" title="1. 实现Dao层代码"></a>1. 实现Dao层代码</h2><ol>
<li><p>在<code>StudentMapper.java</code>接口中写上删除函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据学生编号修改学生年龄</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> number 学生编号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age 要求的年龄</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 影响数据库的行数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateAgeByNumber</span><span class="params">(<span class="meta">@Param(&quot;number&quot;)</span> String number, <span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>StudentMapper.xml</code>中写上<code>StduentMapper.java</code>文件中<code>updateAgeByNumber(String number, Integer age);</code>方法对应的sql语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAgeByNumber&quot;</span>&gt;</span></span><br><span class="line">    update student</span><br><span class="line">    set age = #&#123;age&#125;</span><br><span class="line">    where number = #&#123;number&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-实现Service层-2"><a href="#2-实现Service层-2" class="headerlink" title="2. 实现Service层"></a>2. 实现Service层</h2><ol>
<li><p>在<code>StudentService.java</code>接口中写上更新函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据学生编号更新学生年龄</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> number 学生编号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age 学生年龄</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否更新成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateAgeByNumber</span><span class="params">(String number, Integer age)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>StudentServiceImpl.java</code>类中实现<code>StudentService.java</code>接口中<code>updateAgeByNumber(String number, Integer age)</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateAgeByNumber</span><span class="params">(String number, Integer age)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (number == <span class="literal">null</span> || number.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> studentMapper.updateAgeByNumber(number, age) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-实现Controller层-2"><a href="#3-实现Controller层-2" class="headerlink" title="3. 实现Controller层"></a>3. 实现Controller层</h2><p>在<code>StudetController.java</code>中写上更新学生年龄的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/student/updateAgeByNumber&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateAgeByNumber</span><span class="params">(String number, Integer age)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> studentService.updateAgeByNumber(number, age) ? <span class="string">&quot;更新成功&quot;</span> : <span class="string">&quot;更新失败&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-测试-2"><a href="#4-测试-2" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>使用<code>postman</code> 模拟发送<code>&quot;/student/updateAgeByNumber&quot;请求</code></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304212128664.jpg" alt="Screenshot 2023-04-21 at 00.36.25"></p>
<p>查看数据库，可以看到学生编号为M202102的学生的年龄更新成了22</p>
<p>![Screenshot 2023-04-21 at 00.37.55](<a href="https://naiswang.oss-cn-shanghai.aliyuncs.com/images/Screenshot">https://naiswang.oss-cn-shanghai.aliyuncs.com/images/Screenshot</a> 2023-04-21 at 00.37.55.jpg)</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着React官网学习2--增加交互性</title>
    <url>/83da8530/</url>
    <content><![CDATA[<blockquote>
<p>本文记录React官网第二章相关内容，给页面增加交互性。</p>
</blockquote>
<span id="more"></span>

<h1 id="响应处理事件"><a href="#响应处理事件" class="headerlink" title="响应处理事件"></a>响应处理事件</h1><blockquote>
<p>我们可以给JSX添加事件处理器，以此给响应相关事件如点击、hover、输入框聚焦等事件。</p>
</blockquote>
<p>React中无论是HTML内置的标签还是自定义组件，事件处理器都是通过props来传递，再由子组件触发，这为一个完整流程。</p>
<p>因此，该过程主要分为两步：</p>
<ul>
<li>给子组件添加事件处理器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function Button() &#123;</span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    alert(&#x27;You clicked me!&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子组件获取事件处理器并在合适时机调用</li>
</ul>
<p>​	对应HTML内置标签会自动执行，如上面代码中给<code>onClick</code>传入的<code>handleClick</code>方法会在按钮点击时自动执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Button(&#123; onClick, children &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;onClick&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">export default function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">  	&lt;div&gt;</span><br><span class="line">    	&lt;Button onClick=&#123;() =&gt; alert(&#x27;子组件按钮被点击&#x27;)&#125;&gt;子组件点击事件响应&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父组件完成子组件相关事件响应是通过props来完成的，即子组件的事件名对应于props对象的属性名，所以子组件的事件名可以语义化。</p>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>DOM事件流有三个阶段：事件捕获、目标、事件冒泡。默认为事件冒泡，即由目标元素开始响应事件，一级一级向上依次完成相应事件响应。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/f1ower1ang/blogPicture@master/images/202304231915563.png" alt="img"></p>
<p>在React中，会对事件处理函数传入一个事件对象作为参数，该对象中有一个方法<code>e.stopPropagation()</code>可以阻止事件冒泡。如果不想让事件冒泡，可以使用下面的方法阻止该行为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Button(&#123; onClick, children &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;e =&gt; &#123;</span><br><span class="line">      e.stopPropagation();</span><br><span class="line">      onClick();</span><br><span class="line">    &#125;&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h2><p>内置的HTML标签中，有些事件存在默认行为（form中submit后会导致页面刷新），这些行为和事件冒泡是两回事。要阻止默认行为可以执行<code>e.preventDefault()</code>，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function Signup() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit=&#123;e =&gt; &#123;</span><br><span class="line">      e.preventDefault();</span><br><span class="line">      alert(&#x27;Submitting!&#x27;);</span><br><span class="line">    &#125;&#125;&gt;</span><br><span class="line">      &lt;input /&gt;</span><br><span class="line">      &lt;button&gt;Send&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="状态是组件的内存"><a href="#状态是组件的内存" class="headerlink" title="状态是组件的内存"></a>状态是组件的内存</h1><blockquote>
<p>随着页面产生交互，组件也会变化，如输入表单信息、添加商品至购物车等行为，相应变化的数据也应被记住，这些变化的数据统称为组件的状态。</p>
</blockquote>
<p>React组件是函数式组件，每次组件渲染时都会重新执行函数，若使用局部变量还保存组件数据，则会在组件渲染时重新初始化，另外，修改局部变量不会触发组件重新渲染。React提供一个hook——<code>useState</code>，它返回一个数组，包含两个成员：</p>
<ul>
<li>一个是state变量，维护着最新的组件数据</li>
<li>一个是state setter函数，用于更新state变量并触发React重新渲染组件</li>
</ul>
<p><code>useState</code>使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;</span><br><span class="line">const [index, setIndex] = useState(0)</span><br><span class="line"></span><br><span class="line">// 更新index值</span><br><span class="line">setIndex(index + 1)</span><br><span class="line">// 或者（i为最新的index）</span><br><span class="line">setIndex(i =&gt; i + 1)</span><br></pre></td></tr></table></figure>

<h2 id="React如何管理State"><a href="#React如何管理State" class="headerlink" title="React如何管理State"></a>React如何管理State</h2><p>在使用<code>useState</code>时，除了设置初始值，没有其他标识符对状态进行标记。React以一种较为巧妙的方式完成，hooks在同一个组件渲染时会以稳定的顺序执行，在React内部，会为每个组件设置一个数组，用来保存<code>useState</code>返回值，下次组件渲染，再根据<code>useState</code>的执行顺序，返回对应数组子项。简易实现代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> componentHooks = [] <span class="comment">// 保存当前组件所有useState的返回值</span></span><br><span class="line"><span class="keyword">let</span> currentHookIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">initialState</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> pair = componentHooks[currentHookIndex] <span class="comment">// [state, setState]</span></span><br><span class="line">  <span class="keyword">if</span> (pair) &#123; <span class="comment">// 组件不是第一次渲染</span></span><br><span class="line">    currentHookIndex++</span><br><span class="line">    <span class="keyword">return</span> pair</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 组件首次渲染</span></span><br><span class="line">  pair = [initialState, setState]</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setState</span>(<span class="params">nextState</span>) &#123;</span><br><span class="line">    <span class="comment">// 值没有变化，不会触发视图更新</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">is</span>(nextState, pair[<span class="number">0</span>])) <span class="keyword">return</span></span><br><span class="line">    pair[<span class="number">0</span>] = nextState</span><br><span class="line">    <span class="comment">// 触发组件更新</span></span><br><span class="line">    <span class="title function_">updateDOM</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把useState返回值保存下来</span></span><br><span class="line">  componentHooks[currentHookIndex++] = pair</span><br><span class="line">  <span class="keyword">return</span> pair</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="渲染并提交"><a href="#渲染并提交" class="headerlink" title="渲染并提交"></a>渲染并提交</h1><blockquote>
<p>组件显示到屏幕之前需由React处理相关渲染过程，其主要包含三个步骤：触发渲染、渲染组件、提交转换为DOM</p>
</blockquote>
<h2 id="渲染触发"><a href="#渲染触发" class="headerlink" title="渲染触发"></a>渲染触发</h2><p>组件渲染的原因主要有两个：</p>
<ul>
<li><p>该组件是第一次渲染</p>
<ul>
<li>当app启动时，会触发组件的第一次渲染。该过程是调用根组件的<code>render</code>方法完成的，主要实现如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Image from &#x27;./Image.js&#x27;;</span><br><span class="line">import &#123; createRoot &#125; from &#x27;react-dom/client&#x27;;</span><br><span class="line"></span><br><span class="line">// 把目标DOM节点转为根组件，后续组件将作为该节点的子节点渲染</span><br><span class="line">const root = createRoot(document.getElementById(&#x27;root&#x27;))</span><br><span class="line">// 初始触发渲染</span><br><span class="line">root.render(&lt;Image /&gt;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>该组件或其祖先的状态被修改</p>
<ul>
<li>一旦组件初始化渲染，我们可以通过修改组件状态来触发其重新渲染。需要注意的是，组件状态的更改不会立刻引起组件重新渲染，React会将其放到队列排队等候，且这个过程是异步的。</li>
</ul>
</li>
</ul>
<h2 id="组件渲染"><a href="#组件渲染" class="headerlink" title="组件渲染"></a>组件渲染</h2><p>在触发渲染这个操作后，React会执行组件来了解展示的内容。<strong>“渲染”就是React执行组件</strong>。</p>
<ul>
<li>第一次渲染，React执行root组件的渲染函数</li>
<li>对于后续渲染，React执行组件状态变化的组件。</li>
</ul>
<p>组件渲染是递归的过程：如果更新后的组件返回其他组件，React将递归处理其子组件，直到当前组件没有嵌套其他组件。</p>
<p><strong>注意</strong>：函数组件的渲染必须是纯函数。</p>
<ul>
<li>相同的输入应返回相同的结果。即给函数组件传入相同的参数，返回的JSX也应相同的。</li>
<li>专注自己的业务。即不应该修改任何出现在渲染前阶段的变量。</li>
</ul>
<h2 id="将相关变化转换为DOM"><a href="#将相关变化转换为DOM" class="headerlink" title="将相关变化转换为DOM"></a>将相关变化转换为DOM</h2><p>React渲染组件后，会将组件的变化转换为DOM。</p>
<ul>
<li>第一次渲染，React将调用<code>appendChild()</code>来插入所有创建的DOM节点。</li>
<li>对于后续渲染，React将使用最少的操作（渲染时计算得来）使得DOM匹配最新的渲染结果。</li>
</ul>
<p><strong>React只修改两次渲染结果不一样的DOM节点</strong>。例如下面有一个组件，该组件会因为传入的props不一样而重新渲染，但是<code>input</code>元素的内容并不会改变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function Clock(&#123; time &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">  	&lt;&gt;</span><br><span class="line">    	&lt;h1&gt;&#123;time&#125;&lt;/h1&gt;</span><br><span class="line">    	&lt;input /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="状态也为快照"><a href="#状态也为快照" class="headerlink" title="状态也为快照"></a>状态也为快照</h1><blockquote>
<p>状态不仅作为JS变量允许修改和读取，还能作为组件快照，记录组件更新前的信息。</p>
</blockquote>
<h2 id="设置状态会触发渲染"><a href="#设置状态会触发渲染" class="headerlink" title="设置状态会触发渲染"></a>设置状态会触发渲染</h2><p>当我们调用<code>useState()</code>返回的状态设置函数<code>setState</code>，如这里的<code>[state, setState] = useState(null)</code>，若状态发生变化(<code>Object.is()</code>判断)，它会触发组件的渲染，从而重新执行函数组件，获取最新的状态，但在组件刷新前并不会修改当前已有的状态。</p>
<h2 id="渲染会及时获取快照"><a href="#渲染会及时获取快照" class="headerlink" title="渲染会及时获取快照"></a>渲染会及时获取快照</h2><p>从函数组件返回的JSX就像是当前组件的快照，它的props、事件处理函数、局部变量等都是由渲染时的状态计算而来的，状态存在于函数组件之外。</p>
<p>这里可以举一个例子：每点击一次按钮，给一个数+3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">export default function Counter() &#123;</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;number&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">        setNumber(number + 1);</span><br><span class="line">      &#125;&#125;&gt;+3&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而执行结果并不符合预期，这是因为执行<code>setNumber(number + 1)</code>并不会立即修改当前的<code>number</code>，假如当前<code>number=0</code>所以相当于执行了三次<code>setNumber(0 + 1)</code>。而这个<code>number</code>就相当于当前组件的快照，它会随着组件的重新渲染而更新。</p>
<p>更有趣的一个例子：每点击一次按钮，让<code>number+5</code>并3s后alert当前<code>number</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">export default function Counter() &#123;</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;number&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setNumber(number + 5);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          alert(number);</span><br><span class="line">        &#125;, 3000);</span><br><span class="line">      &#125;&#125;&gt;+5&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是：alert的结果是上一次组件更新前的数，如当前<code>number=0</code>，点击后，过了3s，<code>alert还是0</code>。由此可见，<strong>一次组件渲染对应一个状态变量值</strong>，这里也可以理解为<strong>闭包</strong>。</p>
<h1 id="排队更新状态"><a href="#排队更新状态" class="headerlink" title="排队更新状态"></a>排队更新状态</h1><blockquote>
<p>状态更新会引起组件重新渲染，React将依次处理，但有时我们需要在组件下一次渲染前对状态进行多个操作，并希望能根据最新状态来进行相关操作。</p>
</blockquote>
<p>之前我们知道组件中的状态保存着当前组件渲染的快照，因此调用状态的<code>setter</code>方法不会修改当前状态值信息，但有时批量修改状态需要根据最新的状态来完成，例如给一个状态<code>number+3</code>。前文提出，连续执行三次<code>setNumber(number+1)</code>并不能得到想要的结果。这时React允许我们给<code>setter</code>传入函数，诸如这种<code>setNumber(n =&gt; n + 1)</code>，传入的回调函数的参数就是最新的状态值，返回值作为要设置的状态值。</p>
<p>因此我们只需稍加修改一下点击事件处理函数，便可得到想要的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const handleClick = () =&gt; &#123;</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>React会对其进行排队处理：</p>
<table>
<thead>
<tr>
<th align="center">queued update</th>
<th align="center"><code>n</code></th>
<th align="center">returns</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>n =&gt; n + 1</code></td>
<td align="center"><code>0</code></td>
<td align="center"><code>0 + 1 = 1</code></td>
</tr>
<tr>
<td align="center"><code>n =&gt; n + 1</code></td>
<td align="center"><code>1</code></td>
<td align="center"><code>1 + 1 = 2</code></td>
</tr>
<tr>
<td align="center"><code>n =&gt; n + 1</code></td>
<td align="center"><code>2</code></td>
<td align="center"><code>2 + 1 = 3</code></td>
</tr>
</tbody></table>
<p>如果点击事件处理函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const handleClick = () =&gt; &#123;</span><br><span class="line">  setNumber(number + 5);</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的处理过程如下：</p>
<table>
<thead>
<tr>
<th align="center">queued update</th>
<th align="center"><code>n</code></th>
<th align="center">returns</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“replace with <code>5</code>”</td>
<td align="center"><code>0</code> (未使用)</td>
<td align="center"><code>5</code></td>
</tr>
<tr>
<td align="center"><code>n =&gt; n + 1</code></td>
<td align="center"><code>5</code></td>
<td align="center"><code>5 + 1 = 6</code></td>
</tr>
</tbody></table>
<p>稍加改动一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const handleClick = () =&gt; &#123;</span><br><span class="line">  setNumber(number + 5);</span><br><span class="line">  setNumber(n =&gt; n + 1);</span><br><span class="line">  setNumber(42);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<table>
<thead>
<tr>
<th align="center">queued update</th>
<th align="center"><code>n</code></th>
<th align="center">returns</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“replace with <code>5</code>”</td>
<td align="center"><code>0</code> (unused)</td>
<td align="center"><code>5</code></td>
</tr>
<tr>
<td align="center"><code>n =&gt; n + 1</code></td>
<td align="center"><code>5</code></td>
<td align="center"><code>5 + 1 = 6</code></td>
</tr>
<tr>
<td align="center">“replace with <code>42</code>”</td>
<td align="center"><code>6</code> (unused)</td>
<td align="center"><code>42</code></td>
</tr>
</tbody></table>
<p>因为最后一个<code>setter</code>，后续的结果始终为：<code>number=42</code></p>
<h1 id="更新状态中的对象"><a href="#更新状态中的对象" class="headerlink" title="更新状态中的对象"></a>更新状态中的对象</h1><blockquote>
<p>任何JS数据类型都能作为状态，包括对象。但如果要更新状态对象，需要先复制一份原始的，然后在其基础上修改，最终调用状态的setter方法。</p>
</blockquote>
<h2 id="把状态视为只读的"><a href="#把状态视为只读的" class="headerlink" title="把状态视为只读的"></a>把状态视为只读的</h2><p>不论是状态值类型为基础类型还是对象类型，我们都应该将其视为<strong>只读</strong>。</p>
<p>例如我们想要实现让一个圆点跟随鼠标移动，这里会定义一个状态对象来保存鼠标的坐标，然后设置圆点的<code>transform</code>属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">export default function MovingDot() &#123;</span><br><span class="line">  const [position, setPosition] = useState(&#123;</span><br><span class="line">    x: 0,</span><br><span class="line">    y: 0</span><br><span class="line">  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div</span><br><span class="line">      onPointerMove=&#123;e =&gt; &#123;</span><br><span class="line">        position.x = e.clientX;</span><br><span class="line">        position.y = e.clientY;</span><br><span class="line">      &#125;&#125;</span><br><span class="line">      style=&#123;&#123;</span><br><span class="line">        position: &#x27;relative&#x27;,</span><br><span class="line">        width: &#x27;100vw&#x27;,</span><br><span class="line">        height: &#x27;100vh&#x27;,</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">      &lt;div className=&quot;red-dot&quot; style=&#123;&#123;</span><br><span class="line">        transform: `translate($&#123;position.x&#125;px, $&#123;position.y&#125;px)`,</span><br><span class="line">      &#125;&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直觉来讲，可以直接修改<code>position</code>对象的属性值，但这样是不符合React设计规则的，且结果也没达到预期，其一是没有调用<code>setPosition</code>来更新状态，但这似乎没多大影响，个人猜想是两次渲染的<code>position</code>都相同，不会触发DOM更新。虽然有时候直接在原对象基础上修改能达到预期效果，但不建议这么做。</p>
<p>正确的做法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onPointerMove=&#123;e =&gt; &#123;</span><br><span class="line">  setPosition(&#123;</span><br><span class="line">    x: e.clientX,</span><br><span class="line">    y: e.clientY</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用扩展运算符复制对象"><a href="#使用扩展运算符复制对象" class="headerlink" title="使用扩展运算符复制对象"></a>使用扩展运算符复制对象</h2><p>在前一个例子中，<code>position</code>对象总是根据当前位置信息来更新，但通常来讲，我们不需要更新状态对象中所有属性，因此可以使用扩展运算符来复制原有属性，然后按需更新属性。</p>
<p>例如，对于一个<code>person</code>对象，我需要根据<code>input</code>来修改其邮箱，朴素做法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setPerson(&#123;</span><br><span class="line">  email: e.target.value, // New email from the input</span><br><span class="line">  lastName: person.lastName,</span><br><span class="line">  firstName: person.firstName</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>也可以用扩展运算符<code>...</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setPerson(&#123;</span><br><span class="line">  ...person, // Copy the old fields</span><br><span class="line">  email: e.target.value // But override this one</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="更新嵌套对象"><a href="#更新嵌套对象" class="headerlink" title="更新嵌套对象"></a>更新嵌套对象</h2><p>有时候状态对象的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [person, setPerson] = useState(&#123;</span><br><span class="line">  name: &#x27;Niki de Saint Phalle&#x27;,</span><br><span class="line">  artwork: &#123;</span><br><span class="line">    title: &#x27;Blue Nana&#x27;,</span><br><span class="line">    city: &#x27;Hamburg&#x27;,</span><br><span class="line">    image: &#x27;https://i.imgur.com/Sd1AgUOm.jpg&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果想更新<code>person.artwork.city</code>，通常我们会直接修改原有值 <code>person.artwork.city = &#39;New Delhi&#39;;</code>，但在React中这是不允许的，因此通常会使用以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const nextArtwork = &#123; ...person.artwork, city: &#x27;New Delhi&#x27; &#125;;</span><br><span class="line">const nextPerson = &#123; ...person, artwork: nextArtwork &#125;;</span><br><span class="line">setPerson(nextPerson);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setPerson(&#123;</span><br><span class="line">  ...person, // Copy other fields</span><br><span class="line">  artwork: &#123; // but replace the artwork</span><br><span class="line">    ...person.artwork, // with the same one</span><br><span class="line">    city: &#x27;New Delhi&#x27; // but in New Delhi!</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样显得比较繁琐，因此出现了第三方库<code>use-immer</code>来简化操作</p>
<h2 id="使用Immer来简化更新逻辑"><a href="#使用Immer来简化更新逻辑" class="headerlink" title="使用Immer来简化更新逻辑"></a>使用Immer来简化更新逻辑</h2><p>当前状态对象嵌套层级过深，更新操作反而成为体力活，有点本末倒置了。这里可以使用<code>use-immer</code>来简化相关操作，使得状态对象更新符合直觉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updatePerson(draft =&gt; &#123;</span><br><span class="line">  draft.artwork.city = &#x27;Lagos&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>Immer工作原理</strong>:</p>
<blockquote>
<p>Immer提供的参数(<code>draft</code>)是一种特殊类型的对象，称为代理，它可以“记录”在该对象上的操作。这就是为什么我们可以随心所欲地修改它的原因！在该引擎下，Immer可以知道<code>draft</code>对象的变化，并产生与之对应的全新对象。</p>
</blockquote>
<p><strong>Immer使用方式</strong>：</p>
<ul>
<li>执行<code>npm install use-immer</code>，将Immer添加到依赖库中</li>
<li>将<code>import &#123; useState &#125; from react</code>替换为<code>import &#123; useImmer &#125; from &#39;use-immer&#39;</code></li>
</ul>
<h2 id="为何不建议在React直接修改状态"><a href="#为何不建议在React直接修改状态" class="headerlink" title="为何不建议在React直接修改状态"></a>为何不建议在React直接修改状态</h2><ul>
<li><strong>调试</strong>：如果使用<code>console.log</code>并且不修改状态，那过去的日志就不会因为最近的状态更改而被破坏。因此，我们可以清楚地看到状态如何在渲染之间变化。</li>
<li><strong>优化</strong>：如果当前的props或state与下一个的相同，则常见的React优化策略依赖可以跳过。因为如果你从未修改过状态，那么这个检查过程是非常快的。只需判断<code>prevObj===obj</code>，就可以确定它内部没有任何更改。</li>
<li><strong>新功能</strong>：当前正在构建的React新功能依赖于将状态视为快照。如果改变状态，这可能会阻止我们使用React的新功能。</li>
<li><strong>需求更改</strong>：一些应用程序功能，如实现撤消&#x2F;恢复、显示、更改、历史记录，或允许用户将表单重置为以前的值，在没有任何变化的情况下更容易执行。这是因为我们可以将过去的状态副本保存在内存中，并在适当的时候重用它们。如果我们不按规则执行，像这样的功能以后可能很难添加。</li>
<li><strong>更简单的实现</strong>：因为React不依赖于状态直接修改，所以它不需要对对象做任何特殊的处理。不需要将它们封装到代理中来劫持它们的属性，也不需要像许多“响应式”解决方案那样在初始化时做其他工作。这也是为什么React允许我们将任何对象置于状态，无论对象有多大，都不会有额外的性能或陷阱。</li>
</ul>
<h1 id="更新状态中的数组"><a href="#更新状态中的数组" class="headerlink" title="更新状态中的数组"></a>更新状态中的数组</h1><blockquote>
<p>在JS中，数组是可以修改的，但在React将其作为状态因为视其为不可修改的。和对象一样，当我们想更新状态数组，需要复制一份，在副本上进行操作。</p>
</blockquote>
<h2 id="非侵入式更新数组"><a href="#非侵入式更新数组" class="headerlink" title="非侵入式更新数组"></a>非侵入式更新数组</h2><p>和对象一样，在React状态中我们应该把数组视为<strong>只读</strong>的。每次更新状态数组时，我们需要给状态的<code>setter</code>方法传入新的数组，可以通过数组方法中相关方法生成副本如<code>filter()</code>和<code>map()</code>。</p>
<p>数组的成员方法中分为两类：会更改原数组、不更改原数组。</p>
<table>
<thead>
<tr>
<th></th>
<th>avoid (mutates the array)</th>
<th>prefer (returns a new array)</th>
</tr>
</thead>
<tbody><tr>
<td>adding</td>
<td><code>push</code>, <code>unshift</code></td>
<td><code>concat</code>, <code>[...arr]</code> spread syntax (<a href="https://react.dev/learn/updating-arrays-in-state#adding-to-an-array">example</a>)</td>
</tr>
<tr>
<td>removing</td>
<td><code>pop</code>, <code>shift</code>, <code>splice</code></td>
<td><code>filter</code>, <code>slice</code> (<a href="https://react.dev/learn/updating-arrays-in-state#removing-from-an-array">example</a>)</td>
</tr>
<tr>
<td>replacing</td>
<td><code>splice</code>, <code>arr[i] = ...</code> assignment</td>
<td><code>map</code> (<a href="https://react.dev/learn/updating-arrays-in-state#replacing-items-in-an-array">example</a>)</td>
</tr>
<tr>
<td>sorting</td>
<td><code>reverse</code>, <code>sort</code></td>
<td>copy the array first (<a href="https://react.dev/learn/updating-arrays-in-state#making-other-changes-to-an-array">example</a>)</td>
</tr>
</tbody></table>
<h2 id="给数组添加元素"><a href="#给数组添加元素" class="headerlink" title="给数组添加元素"></a>给数组添加元素</h2><p><code>push()</code>会更改原数组，因此我们可以使用扩展运算符<code>...</code>来拷贝原数组，然后在根据需求在数组的头或尾添加元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 数组尾追加</span><br><span class="line">setArtists(</span><br><span class="line">  [ // with a new array</span><br><span class="line">    ...artists, // that contains all the old items</span><br><span class="line">    &#123; id: nextId++, name: name &#125; // and one new item at the end</span><br><span class="line">  ]</span><br><span class="line">);</span><br><span class="line">// 数组头插入</span><br><span class="line">setArtists([</span><br><span class="line">  &#123; id: nextId++, name: name &#125;,</span><br><span class="line">  ...artists // Put old items at the end</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h2 id="从数组中移除元素"><a href="#从数组中移除元素" class="headerlink" title="从数组中移除元素"></a>从数组中移除元素</h2><p>可以使用<code>filter()</code>方法将不需要的元素过滤掉，等价于从数组中移除某个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const removeArtist = (artist) =&gt; &#123;</span><br><span class="line">  setArtists(</span><br><span class="line">  	artists.filter(a =&gt; a.id !== artist.id)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对数组进行变换"><a href="#对数组进行变换" class="headerlink" title="对数组进行变换"></a>对数组进行变换</h2><p>如果要对数组的部分或所有元素进行批量修改，可以使用<code>map()</code>方法批量操作，它会返回新的数组。</p>
<p>例如，每点击一次按钮，只让圆点向下移动，方块不动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">let initialShapes = [</span><br><span class="line">  &#123; id: 0, type: &#x27;circle&#x27;, x: 50, y: 100 &#125;,</span><br><span class="line">  &#123; id: 1, type: &#x27;square&#x27;, x: 150, y: 100 &#125;,</span><br><span class="line">  &#123; id: 2, type: &#x27;circle&#x27;, x: 250, y: 100 &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export default function ShapeEditor() &#123;</span><br><span class="line">  const [shapes, setShapes] = useState(</span><br><span class="line">    initialShapes</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    const nextShapes = shapes.map(shape =&gt; &#123;</span><br><span class="line">      if (shape.type === &#x27;square&#x27;) &#123;</span><br><span class="line">        // No change</span><br><span class="line">        return shape;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // Return a new circle 50px below</span><br><span class="line">        return &#123;</span><br><span class="line">          ...shape,</span><br><span class="line">          y: shape.y + 50,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // Re-render with the new array</span><br><span class="line">    setShapes(nextShapes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        Move circles down!</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &#123;shapes.map(shape =&gt; (</span><br><span class="line">        &lt;div</span><br><span class="line">          key=&#123;shape.id&#125;</span><br><span class="line">          style=&#123;&#123;</span><br><span class="line">          background: &#x27;purple&#x27;,</span><br><span class="line">          position: &#x27;absolute&#x27;,</span><br><span class="line">          left: shape.x,</span><br><span class="line">          top: shape.y,</span><br><span class="line">          borderRadius:</span><br><span class="line">            shape.type === &#x27;circle&#x27;</span><br><span class="line">              ? &#x27;50%&#x27; : &#x27;&#x27;,</span><br><span class="line">          width: 20,</span><br><span class="line">          height: 20,</span><br><span class="line">        &#125;&#125; /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改数组中的某个元素"><a href="#修改数组中的某个元素" class="headerlink" title="修改数组中的某个元素"></a>修改数组中的某个元素</h2><p>同样可以借助<code>map()</code>方法，只对某个下标的元素进行变化，其他不变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function handleIncrementClick(index) &#123;</span><br><span class="line">    const nextCounters = counters.map((c, i) =&gt; &#123;</span><br><span class="line">      if (i === index) &#123;</span><br><span class="line">        // Increment the clicked counter</span><br><span class="line">        return c + 1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // The rest haven&#x27;t changed</span><br><span class="line">        return c;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    setCounters(nextCounters);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="在数组某一位置插入元素"><a href="#在数组某一位置插入元素" class="headerlink" title="在数组某一位置插入元素"></a>在数组某一位置插入元素</h2><p>这里可以将扩展运算符<code>...</code>和<code>slice()</code>方法搭配使用。</p>
<p>例如，我想在数组下标为1的地方插入一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function insertArtist(artist) &#123;</span><br><span class="line">  const insertAt = 1; // Could be any index</span><br><span class="line">    const nextArtists = [</span><br><span class="line">      // Items before the insertion point:</span><br><span class="line">      ...artists.slice(0, insertAt),</span><br><span class="line">      // New item:</span><br><span class="line">      artist,</span><br><span class="line">      // Items after the insertion point:</span><br><span class="line">      ...artists.slice(insertAt)</span><br><span class="line">    ];</span><br><span class="line">    setArtists(nextArtists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对数组做其他的更改"><a href="#对数组做其他的更改" class="headerlink" title="对数组做其他的更改"></a>对数组做其他的更改</h2><p>有时候，只使用<code>map()</code>和<code>filter()</code>方法并不能完成相关操作，例如对数组进行翻转、排序等。这时，我们可以先拷贝原数组，然后在其基础上做相关操作。</p>
<p>例如，我们对数组进行翻转：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function reverseList() &#123;</span><br><span class="line">  const nextList = [...list]</span><br><span class="line">  nextList.reverse()</span><br><span class="line">  setList(nextList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改数组某项元素也是同理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const nextList = [...list];</span><br><span class="line">nextList[0].seen = true; // Problem: mutates list[0]</span><br><span class="line">setList(nextList);</span><br></pre></td></tr></table></figure>

<h2 id="更新数组中的对象"><a href="#更新数组中的对象" class="headerlink" title="更新数组中的对象"></a>更新数组中的对象</h2><p><code>slice()</code>和扩展运算符<code>...</code>为浅拷贝，当我们使用同一个数组（元素均为对象）给不同状态初始化时，如果在元素上直接修改，会影响其他状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">let nextId = 3;</span><br><span class="line">const initialList = [</span><br><span class="line">  &#123; id: 0, title: &#x27;Big Bellies&#x27;, seen: false &#125;,</span><br><span class="line">  &#123; id: 1, title: &#x27;Lunar Landscape&#x27;, seen: false &#125;,</span><br><span class="line">  &#123; id: 2, title: &#x27;Terracotta Army&#x27;, seen: true &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const [myList, setMyList] = useState(initialList)</span><br><span class="line">const [yourList, setYourList] = useState(initialList)</span><br></pre></td></tr></table></figure>

<p>如果直接这样操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const myNextList = [...myList];</span><br><span class="line">const artwork = myNextList.find(a =&gt; a.id === artworkId);</span><br><span class="line">artwork.seen = nextSeen; // Problem: mutates an existing item</span><br><span class="line">setMyList(myNextList);</span><br></pre></td></tr></table></figure>

<p><code>yourList</code>也会受影响，正确的方法应使用新的对象覆盖，例如可以使用<code>map()</code>进行相关操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setMyList(myList.map(artwork =&gt; &#123;</span><br><span class="line">  if (artwork.id === artworkId) &#123;</span><br><span class="line">    // Create a *new* object with changes</span><br><span class="line">    return &#123; ...artwork, seen: nextSeen &#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // No changes</span><br><span class="line">    return artwork;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h2 id="使用Immer简化更新逻辑"><a href="#使用Immer简化更新逻辑" class="headerlink" title="使用Immer简化更新逻辑"></a>使用Immer简化更新逻辑</h2><p>和对象一样，我们可以使用<code>Immer</code>来简化数组的更新操作，使其更符合逻辑。</p>
<p>使用<code>Immer</code>更新数组中的对象将变得更加简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [myList, updateMyList] = useImmer(</span><br><span class="line">  initialList</span><br><span class="line">);</span><br><span class="line">const [yourList, updateYourList] = useImmer(</span><br><span class="line">  initialList</span><br><span class="line">);</span><br><span class="line">// 更新myList</span><br><span class="line">updateMyList(draft =&gt; &#123;</span><br><span class="line">  const artwork = draft.find(a =&gt; a.id === id);</span><br><span class="line">  artwork.seen = nextSeen;</span><br><span class="line">&#125;);</span><br><span class="line">// 更新yourList</span><br><span class="line">updateYourList(draft =&gt; &#123;</span><br><span class="line">  const artwork = draft.find(a =&gt; a.id === id);</span><br><span class="line">  artwork.seen = nextSeen;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>跟着官网学习React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
</search>
